<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<script>
			/**
			 * @param {number[]} nums
			 * @return {number}
			 */
			// 1.动态规划（空间未优化，时间复杂度O(n)，空间复杂度O(n)）
			// var maxSubArray = function(nums) {
			// ① 初始化起始状态
			// ② 初始状态dp[0] = nums[0]
			// let dp = [];
			// dp[0] = nums[0];
			// // ③ max 用来记录最大值
			// let max = dp[0];
			// // ④ 一层循环
			// for (let i = 1; i < nums.length; i++) {
			//     // ⑤ 如果前面的数dp[i - 1] > 0，那么前面的加上后面的必定比之前的数大
			//     if (dp[i - 1] > 0) {
			//         dp[i] = dp[i - 1] + nums[i];
			//     } else {
			//         // ⑥ 如果前面的数 < 0，那么后面的数加上这个dp[i - 1]必定比之前的小，那么直接将dp[i] 赋值以nums[i]，使dp[i]从头开始计算
			//         dp[i] = nums[i];
			//     }
			//     // ⑦ 取dp[i]的最大值
			//     max = Math.max(max, dp[i]);
			// }
			// return max;
			// }

			// 2.子序列 动态规划，时间复杂度O(n)，空间复杂度O(n)
			var maxSubArray = function (nums) {
				let dp = [];
				dp[0] = nums[0];
				for (let i = 1; i < nums.length; i++) {
					if (dp[i - 1] > 0) {
						dp[i] = dp[i - 1] + nums[i];
						continue;
					}
					dp[i] = nums[i];
				}
				return Math.max(...dp);
			};

			// 3.贪心（时间复杂度O(n), 空间复杂度O(1)）
			// var maxSubArray = function(nums) {
			//     let res = -Infinity;
			//     let sum = 0;
			//     for (let i = 0; i < nums.length; i++) {
			//         sum += nums[i];
			//         if (sum > res) {
			//             res = sum;
			//         }
			//         if (sum < 0) {
			//             sum = 0;
			//         }
			//     }
			//     return res;
			// };
		</script>
	</body>
</html>
