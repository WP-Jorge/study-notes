### 第一部分

- CSS选择器有哪些

```text
1、id 选择器    #id {}
2、类选择器     .class {}
3、属性选择器   div[data="asd"] {}
4、标签选择器   div {}
5、伪类选择器   :hover {}
6、伪元素选择器 ::before {}
7、通配符选择器  * {}
优先级：!important > 行内样式 > id 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器
```

- css 权重如何计算

```text
1、权重：CSS 权重一共可以分成 4 个等级，a > b > c > d
    (1) style：a 级，样式以行内样式的形式写在标签中，权重计算级别为 a
    (2) id：b 级，样式通过 id 选择器进行匹配时权重计算为 b
    (3) class、[attr='asd']、:hover：c 级，样式通过类选择器、属性选择器、伪类选择器进行匹配时，权重为 c
    (4) tag、::after：d 级。样式通过标签选择器、伪元素选择器进行匹配的时，权重为 d
2、组合：可将多个选择器的组合看作四位的多进制：0 0 0 0
    (1) 从最高位开始往后匹配，靠前的数越大，则优先级最高，如：style="color='red'"   权重：1 0 0 0
    (2) 高位相同看低位，如：1 1 0 0 < 1 2 0 0
3、不参与权重运算：
    (1) !important：!important 是特殊的存在，!important 不在 CSS 权重的运算范围内，而之所以它能让 CSS 选择器
        生效，是因为浏览器碰到 !important 时会进行特殊的判断，当多个 !important 需要进行比较的时候，会先计算其
        权重再与其进行比较
    (2) 通用选择器:：*
    (3) 否定伪类选择器 :not：虽然本身不计算权重，但是写在它里面的 CSS 选择器 是需要计算权重的
    (4) 组合选择器：+、~、>
```

- 重绘与回流，各自的触发时机

```text
1、回流一定引起重绘，重绘不一定引起回流
2、重绘：当页面中的元素样式改变但是不影响它再文档流中的位置时，浏览器会将新的样式赋予给元素并重绘它
    触发时机：
        ① 发生回流时
        ② 当元素中不影响其布局、大小的属性或特殊属性改变时发生重绘：
          color、border-style、visibility、background、text-decoration、background-image、
          background-position、background-repeat、background-size、outline-color、outline、
          outline-style、border-radius、outline-width、box-shadow
3、回流：当渲染树中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或全部文档
    触发时机：
        ① 添加或删除可见的 DOM 元素
        ② 元素尺寸、位置改变：边距、填充、边框、宽高、top 等等
        ③ 内容变化：如 input 输入框内容变化
        ④ 浏览器窗口尺寸改变：如 resize 事件触发
        ⑤ 计算 offsetWidth 和 offsetHeight 属性时
        ⑥ 激活 CSS 伪类：如 :hover
4、性能：
    ① 回流比重绘代价高。有时候即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流
    ② 现代浏览器会对频繁触发回流或重绘的操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，
    如果队列中的任务数量或者事件达到一个阈值时，浏览器会清空队列，进行一次批处理，这样会把多次回流和重绘变成一次
    ③ 当访问如下属性或方法时，浏览器会立刻清空队列：
      clientWidth、clientHeight、clientTop、clientLeft
      offsetWidth、offsetHeight、offsetTop、offsetLeft
      scrollWidth、scrollHeight、scrollTop、scrollLeft
      width、height
      getComputedStyle()
      getBoundingClientRect()
      因为队列中可能会有影响这些属性或方法返回值的操纵，即使获取的信息与队列中操作引发的改变无关，浏览器也会
      强行清空队列，确保拿到的是最精确的结果
5、优化：
    (1) CSS:
        ① 避免使用 table 布局
        ② 尽可能在 DOM 树的最末端改变 class
        ③ 避免设置多层内联样式
        ④ 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
        ⑤ 避免使用 CSS 表达式，如 calc()
    (2) JS:
        ① 避免频繁的样式操作，最好一次性重写好 style 属性，或将样式列表定义为 class 并一次性更改 class 属性
        ② 避免频繁操作 DOM，创建一个 documentFragment，在它上面进行所有的 DOM 操作，最后再把它添加到文档中
        ③ 可以先将元素设置为 display: none，操作结束后再把它显示出来，因为在 display 属性为 none 时进行 DOM
        操作不会进行回流或者重绘
        ④ 避免频繁读取会引起回流或重绘的属性，如果确实需要多次访问，可以先用一个变量储存起来
        ⑤ 对具有复杂动画的元素使用绝对定位，使它脱离文档流，避免引起其父元素或后续元素频繁回流
```

- 怎么解决样式隔离

```text
如今大致有三种样式隔离的解决方案：
1、css in js
    ① 原理：采用 js 来书写样式，这样只有指定的属性才有样式
    ② 缺点：所有的样式都成为行内样式，耦合高
2、css module
    ① 原理：利用模块化工具如 webpack 对每个独立的 dom 元素都绑定一个 hash，并通过这个 hash 来找到对应 dom 元素，实现样式隔离
    ② 缺点：需要用到打包工具
3、shadow dom
    ① 原理：shadow DOM 能隔离 js 和 CSS，在 shadow DOM 中的选择器不会作用域 shadow root 之外，shadow root 之外的样式不会影响到
            shadow DOM 内部，像是 font-family、font-size 可以在内部重写覆盖
    ② 缺点：灵活性低
```

- bfc是什么?作用？

```text
1、BFC：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则
    ① BFC 区域不会和浮动盒子重叠
    ② BFC 是页面上的一个独立容器，子元素不会影响到外面的元素
    ③ 计算 BFC 高度时，浮动元素也会参与计算
2、作用：
    ① 用于清除浮动
    ② 防止 margin 塌陷
3、触发 BFC：
    ① HTML 元素
    ② float 不为 none 的元素
    ③ position 不为 fixed、absolute 的元素
    ④ display 为 flex、flow-root、flow、inline-block、table-cell、table-caption、inline-flex 的元素
    ⑤ overflow 不为 visible 的元素
```

- margin 上边距塌陷

```text
解决方法：
    1、给父元素设置外边框或者内边距
    2、创建一个 BFC：
        ① overflow: hidden | auto | scroll
        ② display: flow-root | flow
        ③ position: relative
```

- 盒模型的理解

```text
1、盒模型由四个部分组成：margin、border、padding、content
2、共有两种盒模型：标准盒模型、IE 盒模型
    ① 标准盒模型的 width 和 height 只包含 content
    ② IE 盒模型的 width 和 height 包含了 border、padding、content
3、可以通过给元素设置 box-sizing 来切换元素的盒模型
    ① content：标准的盒模型（默认值）
    ② border-box：表示 IE 的盒模型（怪异盒模型）
```

- 行内元素、行内块级元素、块级元素的区别

```text
1、行内元素：
    可以多个行内标签存在于同一行，不能直接设置行内标签的宽高、行高以及上下外边距和上下内边距，可以设置左右外边距和左右内边距，靠内容撑开宽高
2、行内块级元素：
    结合行内标签和块级标签的优点，不仅可以对宽高属性生效，还可以让多个行内标签处于同一行显示
3、块级元素：
    独占一行，可设置高度、宽度、行高、外边距，如果不给宽高，块级元素就默认浏览器的宽度
```

- 行内元素、行内块级元素、块级元素有哪些

```text
1、行内元素：
    span、strong、a、i、u、em 等修饰文字的标签
2、行内块级元素：
    img、input、button、audio、video、select
3、块级元素：
    div、h1-h6、hr、form、ol、ul、li、header、header、nav、article、section、aside、figure、figcaption、footer 等
4、差别：
    (1) 行内元素:
        ① 不会独占一行
        ② 默认宽高取决于内容的宽高
        ③ 设置宽高无效
        ④ 设置左右外边距生效，设置上下外边距失效
        ⑤ 设置左右内边距生效。不建议设置上下内边距，设置上下内边距时，内容本身相对于上下位置不变，背景颜色会覆盖上下元素
    (2) 行内块级元素：
        ① 不会独占一行
        ② 设置宽高有效
        ③ 设置外边距有效
        ④ 设置内边距有效
    (3) 块级元素：
        ① 独占一行
        ② 默认宽度是父级的 100%，高度取决于内容高度
        ③ 设置宽高有效
        ④ 设置外边距有效
        ⑤ 设置内边距有效
```

- div 与 span 的区别，加 margin、padding 这二者的区别

```text
1、div：
    (1) 区别：
        ① 块级元素
        ② 一个元素占据一整行
        ③ 宽度为父元素的 100%，高度取决于内容高度
        ④ 可以自由设置宽高
        ⑤ 内外边距有效
2、span：
    (1) 区别：
        ① 行内元素
        ② 一个元素不占据一行
        ③ 宽高默认内容宽高
        ④ 无法设置宽高
        ⑤ 设置左右外边距有效，设置上下外边距失效
        ⑥ 设置左右内边距有效，不推荐设置上下内边距，当设置上下内边距时，内容位置相对上下位置不变，如果元素有背景颜色，
            将覆盖上下元素
```

- 讲一讲flex布局？

```text
1、flex 布局是一种一维的布局模型，它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力
2、flex 布局是基于两根轴进行布局的：主轴和交叉轴，可以通过 flex-direction 进行设置，对于 flex 布局的所有属性都是通过
    这两根轴展开的
3、容器相关属性：
    (1) flex-direction：用于设置主轴方向
        ① row：默认值，以 x 轴主轴方向
        ② row-reverse：以 x 轴反方向为主轴方向
        ③ column：以 y 轴为主轴方向
        ④ column-reverse：以 y 轴反方向为主轴方向
    (2) flex-wrap：用于指定 flex 元素在主轴方向上元素超出容器大小时是否换行
        ① nowrap：默认值，不换行
        ② wrap：换行
        ③ wrap-reserve：换行，第一行在下方，元素排列与 wrap 上下相反
    (3) flex-flow：<flex-direction> || <flex-wrap>; flex-direction 与 flex-wrap 的简写方式
        ① row nowrap：默认值
        ② ...
    (4) justify-content：定义元素在主轴方向上的排列方式
        ① flex-start：默认值，从前往后排列
        ② flex-end：从后往前排列
        ③ center：居中排列
        ④ space-between：分散排列，元素之间空隙相同
        ⑤ space-around：分散排列，容器两边有空隙
    (5) align-items：定义元素在交叉轴上的排列方式
        ① stretch：默认值，如果项目未设置高度或者 auto，将占满整个容器的高度
        ② flex-start：从前往后排列
        ③ flex-end：从后往前排列
        ④ center：居中排列
        ⑤ baseline：基线对齐，如文字的最底部
    (6) align-content：定义多根轴线的对齐方式，如果项目只有一根轴线，那么该轴线将不起作用
        ① stretch：默认值，如果元素不设置高度，则会平分高度并撑满容器高度
        ② flex-start：轴线全部在交叉轴上的起点对齐
        ③ flex-end：轴线全部在交叉轴上的终点对齐
        ④ center：轴线全部在交叉轴的中间对齐
        ⑤ space-between：轴线两端对齐，元素之间距离相同
        ⑥ space-around：轴线两端对齐，边缘有间隙
4、子元素相关属性：flex 元素属性：作用于 flex-box 内的子元素
    (1) order：默认值0，定义元素在容器中的排列顺序，数值越小，排列越靠前
    (2) flex-basis：定义了在分配多余空间之前，项目占的主轴空间，浏览器根据这个特性，计算主轴是由有多余空间，
        当主轴方向为 x 轴时，当设置了 flex-basis，项目的宽度将会失效，flex-basis 需要跟 flex-grow、
        flex-shrink 配合才能发挥效果
        ① 默认值 auto，元素本来的大小
        ② 长度或百分数，指定元素大小或元素大小与原本大小的比例
    (3) flex-grow：默认值 0，定义元素的放大比例，即使有剩余空间，也不会放大
    (4) flex-shrink: 默认值 1，空间不足时将元素缩小，负数无效
    (5) flex：flex-grow、flex-shrink、flex-basis 的简写
        ① auto：1 1 auto
        ② none：0 0 auto
        ③ 非负数：该数为 flex-grow 的值，flex-shrink 取 1，flex-basis 取 0%
        ④ 长度或者百分比：flex-grow 取 1，flex-shrink 取 1，flex-basis 取这个数
        ⑤ 两个非负数：分别为 flex-grow、flex-shrink 的值，flex-basis 取 0%
        ⑥ 一个非负数一个长度或百分比：分别视为 flex-grow、flex-basis 的值，flex-shrink 取 1
    (6) align-self：允许单个元素与其他对齐方式元素不一样
        ① auto：默认值，表示继承父元素的 align-items，如果没有父元素，则等同于 stretch
        ② flex-start
        ③ flex-end
        ④ center
        ⑤ baseline
        ⑥ stretch
```

- 给子元素设置flex:1是什么含义？flex是哪几个属性的简写？flex-shrink默认值是几？剩余空间的分配规则是怎样的？

```text
1、flex: 1：flex: 1 1 0%，flex-grow: 1，flex-shrink: 1，flex-basis: 0%，表示在所有设置 flex 属性的子元素中所占总分数的多少，
用来表示该元素占主轴剩余空间的份数
```

- less sass理解 有什么好处 特点

```text
1、它们都是 CSS 预处理器，CSS 预处理器定义了一种新的语言，用一种专门的编程语言，为 CSS 增加了一些编程的特性，
    将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作
2、为什么会有 CSS 预处理器：
    (1) CSS 具有的缺点：
        ① 语法不够强大，比如无法嵌套书写，导致模块化开发过程中需要书写很多的重复选择器
        ② 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护
    (2) 使用 CSS 预处理器的优点：
        ① 提供 CSS 层缺失的样式复用机制
        ② 减少冗余代码
        ③ 提高样式代码的可维护性
3、Less、Sass 的优点：
    (1) Less 是一门向后兼容的 CSS 扩展语言，Less 仅对 CSS 增加了许多方便的扩展，学习起来方便、容易
        ① 可以在 node、浏览器中运行。
        ② 编译速度快，因为 Less 是使用 JS 编写的，编译速度比其他的 CSS 处理器快
    (2) Sass 是一门强化 CSS 的辅助工具，它在 CSS 的基础上增加了许多高级功能，使 CSS 更加强大
        ① 用户多，更容易找到学习资源
        ② 可编程性强，支持函数、列表、对象、判断、循环等
        ③ 相比 Less 具有更多的功能
4、Less、Sass 的缺点：
    (1) Less：
        ① 与 Sass 相比，Less 提供的框架更少
        ② 模块间耦合较大，重用、维护成本高
    (2) Sass：
        ① CSS 的文件体积和复杂度不可控，调试难度大、成本高
```

- rem 移动端布局原理

```text
1、rem (root em，根 em)
2、所有的 rem 单位会根据 html 标签的 font-size 的大小来进行转换，默认 html 标签的 font-size 为 16px，
那么 1rem 就是 16px，2rem 就是 32px
3、可通过媒体查询配合 rem 进行使用，来实现不同分辨率设备的适配，当设备分辨率大时，通过媒体查询，将 html 标签的 font-size
    缩小，对应使用 rem 布局的地方也将等比例放大；当设备分辨率小的时候，将 html 标签的 font-size 放大，对应使用 rem 的
    地方也会等比缩小。以此来设配不同分辨率设备页面的显示
```

- em

```text
1、em 是相抵长度单位，相对与当前对象文本的字体尺寸。如当前行内文本的字体尺寸为设置，则相对于浏览器的默认字体尺寸，
    一般浏览器默认字体尺寸为 16px，所以 1em = 16px
2、特点：
    (1) em 的值不是固定的，em 会继承父容器的字体大小
```

- position定位

```text
1、position 规定元素的定位，CSS 有三种基本的定位机制：普通流、浮动、绝对定位，除非专门指定，不然页面中的虽有元素都是普通流定位
2、属性：
    (1) static：默认值，没有定位，元素出现在正常的流中
    (2) inherit：继承父元素的 position 属性
    (3) relative：相对定位，相对与自己的初始位置，不脱离文档流，即使元素宽偏移每个位置，元素依然保持其未定位前的形状，它原本所占的空间依然保留
    (4) absolute：绝对定位，使用绝对丁文的元素会脱离文档流，绝对定位的元素相对于自己最近的已定位的祖先元素，如果元素没有已定位的祖先元素，
        那么相对于它的位置的最初包含块（body）
    (5) fixed：固定定位，元素脱离正常文档流，他将通过 top、left、right、bottom 来固定在屏幕的某个位置上
    (6) sticky：粘性定位，结合了 relative、fixed 两种定位功能的一种特殊的定位，常见用于吸顶、吸低效果。
        当元素出现在目标区域的时候表现为 relative 布局的特性，当元素移除目标区域的时候表现 fixed 布局的特性
```

- 伪元素和伪类的使用场景

```text
1、伪类：
    (1) 特点：
        ① 伪类是类，跟 CSS 选择器有关，不存在与 DOM 中
        ② CSS 伪类是用来添加一些选择器的特殊效果
        ③ 伪类前面有一个 ':'，如 a:hover
    (2) 常见属性：
        ① E:link：设置超链接 a 在未访问前的样式
        ② E:visited：设置超链接 a 在已访问后的样式
        ③ E:hover：设置元素在鼠标滑过时的样式
        ④ E:active：设置元素在被用户激活（鼠标点击与释放之间发生的事件）时的样式
        ⑤ E:focus：设置元素在成为输入焦点（该元素的 onfocus 事件触发）时的样式
        ⑥ E:first-child：匹配父元素的第一个子元素 E
        ⑦ E:last-child：匹配父元素最后一个子元素 E
        ⑧ E:nth-child(n)：匹配父元素的第 n 个子元素 E
        ⑨ E:nth-last-child：匹配父元素的倒数第 n 个子元素 E
        ⑩ E:first-of-type：匹配同种类型的第一个同级兄弟元素 E
        ⑪ E:nth-of-type：匹配同种类型的第 n 个同级兄弟元素 E
        ⑫ E:nth-last-of-type：匹配同种类型的倒数第 n 个同级兄弟元素 E
        ⑬ E:checked：匹配用户界面上处于选中发状态的元素 E（用于 input、type 为 radio 与 checked 时）
        ⑭ E:enable：匹配用户界面上处于可用状态的元素 E
        ⑮ E:disable：匹配用户界面上处于禁用的元素 E
        ⑮ E:target：匹配相关 URL 指向的 E 元素
2、伪元素：
    (1) 特点：
        ① 伪元素时创建文档树之外的对象，伪元素也是元素，只不过不存在于 DOM 对象中，但是浏览器审查元素的时候能够看到
        ② CSS3 规定伪元素前面有两个 ':'
    (2) 常见属性：
        ① E:first-letter/E::first-letter：设置对象内的第一个字符样式
        ② E:first-line/E::first-line：设置对象内第一行样式
        ③ E:before/E::before：设置在对象前（依据对象树的逻辑结构）发生的内容，用来和 content 属性一起使用
        ④ E:after/E::after：这是对象后（一句对象树的逻辑结构）发生的内同，用来和 content 属性一起使用
        ⑤ E::placeholder：设置文字对象占位符的样式
        ⑥ E::selection：设置对象被选择时的颜色
3、区别与相同点：
    (1) 相同点：
        ① 伪类与伪元素都不出现在源文件和文档树中，也就是说在 html 源文件中是看不见伪类和伪元素的
    (2) 不同点：
        ① 伪类本质是是弥补常规 CSS 选择器的不足，以便获得更多信息
        ② 伪元素本质上是创建一个有内容的虚拟容器
        ③ 在 CSS3 中伪类和伪元素的语法不同
        ④ 可以同时使用多个伪类，但是只能同时使用一个伪元素
```

- 了解多少种实现元素隐藏的方式？每个方式的区别？

```text
1、display: none
    (1) 元素在页面上彻底消失，元素本来占有的位置会被其他元素占据，会导致浏览器的重绘与重排，不会触发原有的点击事件
2、visibility: hidden
    (1) 元素在页面消失后，其占据的空间依旧会保留，所以只会引起浏览器的重绘，不会引起重排，不会触发原有的点击事件
3、opacity: 0
    (1) 将元素透明度设置为 0 后，元素隐藏，隐藏后依旧占据原有空间，只会引起浏览器重绘，不会引起重排，元素依在，
        可以触发点击事件
4、设置 height、width 等盒模型属性为 0
    (1) 将元素的 margin、border、padding、height、width 等影响元素盒模型的属性设置为 0 后，如果元素内部有
        子元素或内容，也可使用 overflow: hidden 来隐藏子元素，这会引浏览器的重绘与重排，由于鼠标获取不到位置，
        不会触发原有的点击事件
5、position: absolute
    (1) 使用 top、left、right、bottom 将元素的位置移出可视窗口，会造成重绘与重排，鼠标获取不到位置，不会触发点击事件
6、transform: scale(0)
    (1) 将元素设置缩放至 0，元素看不见，元素原来的位置保留，触发浏览器的重绘，不触发重排，无法响应点击事件
```

- css的display属性的三个属性值block,inline和inline-block有什么区别？

```text
1、block：将元素转化为块级元素，拥有块级元素的特性
2、inline：将元素转化为行内元素，拥有行内元素的特性
3、inline-block：将元素转换为行内块级元素，拥有行内块级元素的特性
```

- 除了flex做响应式布局，还有别的方案吗 教程 https://juejin.cn/post/6844903814332432397 ）

```text
1、响应式布局：媒体查询
2、rem 布局：rem + 媒体查询 | rem + js
3、vh 布局
```

- CSS 可以继承的属性

```text
1、字体系列
    (1) font：组合字体
    (2) font-family：规定元素的字体系列
    (3) font-weight：设置字体粗细
    (4) font-size：字体大小
    (5) font-style：字体风格
2、文本系列
    (1) text-indent：文本缩进
    (2) text-align：文本水平对齐
    (3) line-height：行高
    (4) color：颜色
3、元素可见性
    (1) visibility：控制元素可见性
    (2) opacity：元素透明度
4、光标属性
    (1) cursor：控制光标样式
5、所有元素都可以继承
    (1) 元素可见性：
        ① visibility
        ② opacity
    (2) 光标属性：
        ① cursor
6、行内元素可以继承：
    (1) 字体系列
    (2) 文本系列除 text-intent、text-align 以外的所有属性
7、块级元素可以继承：
    (1) text-indent、text-align
8、无继承属性
    (1) display
    (2) 文本属性：vertical-align、text-decoration、text-shadow、white-space、unicode-bidi
    (3) 盒子模型属性：宽高、内外边距、边框
    (4) 背景属性：背景图片、颜色、位置
    (5) 定位属性：浮动、清除浮动、定位 position
    (6) 生成内容属性：content、counter-reset、counter-increment
    (7) 轮廓样式属性：outline-style、outline-width、outline-color、outline
    (8) 页面样式属性：size、page-break-before、page-break、after
```

- display:none 和 visibility:hidden 的区别

```text
1、display: none：元素不生成，其周边的元素会占据它原有的位置，浏览器会重绘与重排，该元素无法触发点击事件
2、visibility: hidden：元素隐藏，但是元素会占据原有的位置，浏览器不会重排，但是会重绘，该元素无法触发点击事件
```

- Scale可以是负数吗，什么效果

```text
可以，会将元素相对于 x 轴与 y 轴进行翻转
```

- CSS浏览器兼容性解决方案

```text
1、为什么会有兼容性问题：
    (1) 由于浏览器厂商很多，而大部分厂商或是同一厂商下的不同版本的浏览器都有各自的内核，所以出现同一段 CSS 代码在不同浏览器之间会有不同的编译效果
    (2) 各家厂商的浏览器内核（渲染引擎）
        ① Chrome 谷歌：之前是 Webkit，已改成 Blink 内核
        ② FireFox 火狐：Gecko
        ③ Safari 苹果：Webkit
        ④ IE：Trident
        ⑤ Opera 欧鹏：现改用 Blink 内核
2、兼容方式：
    (1) 不同浏览器内核的标签默认 margin、padding 不同
        ① CSS：* {padding: 0; margin: 0}，但是性能不好
        ② 引入第三方包 reset.css 进行样式重置
    (2) CSS3 新属性：加前缀兼容早期浏览器
        ① -moz-：火狐浏览器
        ② -webkit-：Safari、谷歌浏览器等使用 Webkit 内核的浏览器
        ③ -o-：Opera 浏览器
        ④ -ms-：IE 浏览器
    (3) CSS hack：针对不同浏览器、不同版本写特定的 CSS，这种针对不同浏览器、不同版本写响应的 CSS code 的过程叫做 CSS hack
        ① 条件 hack
        ② 属性级 hack
        ③ 选择符级 hack
    (4) 自动化插件
        ① 使用 webpack 的 postcss、autoprefixer 插件
```

- li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？

```text
1、原因：浏览器的默认行为是把行内元素间的空白字符（空格、换行、tab）渲染成一个空格，，当 HTML 代码中的 li 有换行时，
    就会把换行后空隙换成一个空格，造成看不见的空白间隔
2、解决方法：
    (1) 将所有的 li 写在一行里
    (2) 将 ul 中的 font-size 设置为 0，再将 li 中的 font-size 设置为 正常大小。让空白的空格大小为 0
    (3) (2) 中的方法在 Safari 中依然存在，通过将 ul 中字符间隔 letter-spacing 设置为 -5px，在将 ul li 
        字符间隔设置成 normal 解决
```

- a链接有四种状态包括未访问(:link)、已访问(:visited)、激活(.active)和悬停(:hover)，声明的顺序是怎样的。

```text
顺序：:link -> :visited -> :hover -> :active
```

- 用过calc()函数吗？它是什么，有什么作用？

```text
1、calc 是一个 CSS3 的属性，可以用来动态的计算长度，允许我们对属性值进行数学运算
2、calc 支持多种长度单位的混合运算，如 百分比、px、em、rem 等
3、解决了在 CSS 中无法动态的进行数学计算的问题
4、缺点：重绘频繁
```

- 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？

```text
1、出现浮动：
    (1) 为了实现类似 word 中文字环绕的效果
    (2) 为了实现一些自适应布局
2、什么时候需要清除浮动：
    (1) 当父元素没有设置高度或宽度时，有需要子元素撑开父元素时需要清除浮动
    (2) 希望文字排列在浮动元素下方，而不是文字环绕
    (3) 浮动元素影响了其父元素的其他元素的排版
3、清除浮动
    (1) clear：给需要清除浮动的元素添加 clear：left | right | both 等样式
    (2) 父元素结束标签之后插入清除浮动的块级元素
    (3) 利用伪元素在需要清除浮动的父元素上（原理同(2)）：::after {content: ''; height: 0; display: block; clear: both}
    (4) 创建 BFC
```

- margin和padding分别适合什么场景使用？

```text
1、margin：
    (1) 需要在 border 外层添加空白
    (2) 空白处不需要背景色
    (3) 上下相邻的两个盒子之间的空白需要相互抵消（margin 折叠）
    (4) 需要使用负值进行布局，margin 允许出现负值，padding 不支持负值
2、padding：
    (1) 需要在 border 内侧添加空白
    (2) 空白处需要背景色
    (3) 上下两个相邻的盒子事件空白需要叠加
    (4) 怪异盒子模型中 padding 会影响盒子的宽高
```

- 元素竖向的百分比设定是相对于容器的高度吗？

```text
是
```

- ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用

```text
1、单冒号：
    (1) 在 CSS 中表示伪类，在 CSS3 问世后，为区分伪类和伪元素，规定伪类使用单冒号。
    (2) 由于双冒号不被低版本的浏览器，所以在开发中也有不少程序员为兼容低版本浏览器，使用单冒号表示伪元素
2、双冒号：
    (1) 在 CSS3 中被修订，用双冒号来表示伪元素
3、::before 和 ::after 的作用
    (1) ::before：在被选元素前面插入内容，不存在于 DOM 中，只存在与页面中
    (2) ::after：在被选元素后面插入内容，不存在于 DOM 中，只存在于页面中
```

- 为什么有时候⽤translate来改变位置⽽不是定位？

```text
原因：
    (1) translate 是 transform 的一个值，改变 transform 不会触发浏览器的重排，因为 transform 直接触发合成，
        transform 使浏览器创建一个 GPU 图层，支持硬件加速，而 position 会使用 CPU，性能更低
    (2) translate 改变位置的时候元素依旧占据原有位置，不会对其他元素产生影响
```

- 阐述一下CSS Sprites

```text
1、介绍：
    (1) sprites 精灵图，通过一张将一些背景图片整合到一张完整的图片中，通过 background-image、background-repeat、
        background-position 的组合进行背景的定位，来精确的展出出在这张完整图片中的部分图片
2、优点：
    (1) 减少浏览器的 http 请求，大大的提升了网站的性能
    (2) 减少图片的大小
3、缺点：
    (1) 制作较为麻烦，必须通过精确的计算拼接，不然在使用时会出现裁剪错位的问题
    (2) 开发成本高，需要程序员一个一个的计算每个图片模块的位置，再显示出来
    (3) 不灵活，如果需要修改整体图片中的某个小图片，那么就需要重新制作新的图片
```

- transition和animation的区别

```text
1、transition：过度动画
    (1) 属性：
        ① transition-property：默认值 all，表示全部。元素的哪一个属性用于过度，备选值：none | all | <属性名>，如 opacity、color
        ② transition-duration：默认值 0s。元素过度持续时间，备选值：<时间>，如 1s
        ③ transition-timing-function：默认值 ease，中间快，两头慢。指定过度时速率函数，备选值：ease | linear | ease-in | 
            ease-out | ease-in-out | cubic-bezier(x1, y1, x2, y2) | step-start | step-end | [, [ start | end ] ]?，
            如 linear、ease-in、steps，可自定义动画
        ④ transition-delay：默认值 0s。指定元素过度延迟时间，备选值：<时间>，如 1s
        ⑤ transition：transition-property、transition-duration、transition-timing-function、transition-delay 整合   
2、animation：动画
    (1) 属性：
        ① animation-name：默认值 none。需要带 keyframes 的名字来描述动画
        ② animation-duration：默认值 0s。元素动画持续时间，例如 1s
        ③ animation-timing-function：默认值 ease。元素动画速率函数，如 linear、ease
        ④ animation-delay：默认值 0s。元素动画延迟执行时间，如 300ms
        ⑤ animation-iteration-count：默认值 1。动画重复次数，如 2
        ⑥ animation-direction：默认值 normal。设置动画播放方向，如 normal、reverse、alternate、alternate-reverse
        ⑦ animation-fill-mode：默认值 none。默认情况下，动画播放完成元素返回其正常状态，可以定义元素再动画结束后或开始前的状态。如 none、forwards、backwards、both
        ⑧ animation-play-state：默认值 running。暂定或恢复动画，如 running、paused
        ⑨ animation：animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction、animation-fill-mode、animation-play-state
3、不同点：
    (1) 触发方式不同：
        ① transition 通过 hover 或者 js 事件来配合
        ② animation 不需要触发事件就可以直接触发，定义动画开始时自动播放
        ③ animation 需要使用 @keyframes 规定动画
    (2) 过程不同：
        ① transition 是过度，是样式值的变化过程，只有开始和结束
        ② animation 是关键帧，通过 keyframes 结合可以设置中间帧的一个状态
    (3) 属性不同：
        ① transition 只触发一次
        ② animation 可以通过设置循环次数、动画结束状态等
    (4) 性能不同：
        ① transition 一般通过 transform 结合进行旋转、缩放等，不会引起不必要的重排与重绘
        ② animation 会改变很多属性，页面的重排与重绘对性能的影响较大，可以在 keyframes 中使用 transform 来替换会引起重排、重绘的属性
```

- 文档流

```text
1、定义：元素在 HTML 中的位置顺序决定排布的过程
2、文档流动方向：
    (1) 从左到右：行内元素在排满一行后才会另起一行
    (2) 从上到下：块级元素每一个元素占据一行，不并列
3、脱离文档流：
    (1) 方法：
        ① position: absolute
        ② position: fixed
        ③ float
```

- 页面导入样式时，使用link和@import有什么区别？

```text
1、link：
    (1) link 是 HTML 提供的标签，出来加载 CSS，还能引入网站图标或是媒体查询
    (2) link 引入 CSS 的时候，页面同时载入 CSS 文件
    (3) link 没有兼容性问题
    (4) link 中的 CSS 可以被 JS 获取来控制
2、@import：
    (1) @import 是 CSS 提供的 CSS 语法规则，只能用来加载 CSS
    (2) @import 要写在 @charset 外任何 CSS 样式之前，不然会被浏览器忽略
    (3) @import 在页面完全载入后再载入 CSS，在网络较慢的时候一开始会没有 CSS 样式
    (4) @import 是 CSS2.1 中提出的，低版本浏览器不支持
    (5) @import 只能通过 CSS 调用
```

- CSS如何阻塞文档解析

```text
1、原因：由于在浏览器解析过程中，如果 CSSOM 没有解析完成就执行 JS 代码，那么 JS 机会获取到错误的 CSS 样式
2、解析过程：DOM 与 CSS 同步解析，当遇到 JS 时会阻塞 JS 后面的代码，待 CSSOM 构建完成后再执行后续的 JS 代码，
    由于 Render 树 依赖于 DOM 树与 CSSOM 树，所以 CSS 会阻止 DOM 树的渲染
```

- 如何优化渲染路径

```text
1、对关键路径进行分析和特性描述：资源数、字节数、长度
2、最大限度的减少关键资源的数量：删除、延迟下载、标记为异步
3、优化关键字节数
4、优化其余关键资源的加载顺序：尽早下载完成所有关键资产，以缩减关键路径长度
```

- 为什么要初始化CSS样式

```text
每个浏览器兼容性不同，默认样式初始值不同
```

- CSS优化、提高性能的方法有哪些？

```text
1、加载性能：
    (1) 压缩 CSSS
    (2) 通过 link 加载 而不是 @import
    (3) 复合样式分开写
2、选择器性能：
    (1) 尽量少用嵌套，可以使用 BEM 的方式解决命名冲突
    (2) 尽量少用标签选择器与通配符选择器
    (3) 利用样式继承，减少代码量
3、渲染性能：
    (1) 少用浮动、定位
    (2) 尽量减少页面重绘、重排
    (3) 采用 CSS 精灵图
    (4) 少用自定义 web 字体
    (5) 少用昂贵属性，如：box-shadow、border-radius、filter、opacity、nth-child 等
    (6) 使用 transform 替换用来改变宽高等会重排的属性
```

- 浏览器是怎样解析CSS选择器的？

```text
1、答案：浏览器从右往左解析选择器
2、原因：
    (1) 如果正向解析，那么浏览器首先需要检查当前元素到 html 的整条路径，找到最上层的元素，再往下找，如果不匹配就需要返回到原先的元素，往下再匹配，回溯若干次才能找到目标元素
    (2) 如果是逆向解析，那么如果当前的元素不是目标元素，那么就直接排除这个元素，只有在匹配时才会不断向上找父节点进行验证
```

- 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

```text
1、结果：16.7ms
2、原因：大多数显示器频率为 60Hz，1s 刷新 60 次，如果多了显示器也无法实现
人眼能够
```

- style标签写在body后与body前有什么区别？

```text
1、写在 body 前有利于浏览器逐步解析的流程：资源下载 -> CSSOM + DOM -> Render Tree -> layout -> paint
2、写在 body 后由于浏览器以逐行的形式对 html 进行解析，当解析到写在末尾的样式表时会导致浏览器停止之前的渲染，等待加载并在解析样式完成后重新渲染，在 windows 的 IE 下可能会出现样式失效导致的页面闪烁问题
```

### 第二部分

```text
链接：https://www.nowcoder.com/discuss/806261?channel=-1&source_id=discuss_terminal_discuss_sim_nctrack&ncTraceId=dccc0aefbd5945b5b3202c0d58afca71.243.16405103396959849
链接：https://www.nowcoder.com/discuss/808087?source_id=discuss_experience_nctrack&channel=-1
```

- CSS3 中有哪些新特性

```text
1、新增 CSS 选择器：
    (1) E~E：p~ul，选择前面有 p 元素的每个 ul 元素
    (2) [attr^=value]：a[src^="https]，选择 src 属性以 https 开头的 a 元素 
    (3) :nth-child(n)
    (4) :nth-of-type(n)
    (5) 等等
2、新样式：
    (1) 边框：
        ① border-radius：圆角边框
        ② box-shadow：元素阴影
        ③ border-image：用图片绘制边框
    (2) 背景：
        ① background-clip：背景从盒模型的指定属性开始
        ② background-origin：指定从那个盒模型的属性开始计算 background-position 的初始位置
        ③ background-size：调整背景图片大小
        ④ background-break：元素可被分为几个独立的盒子
    (3) 文字：
        ① word-wrap：指定是否允许单词在换行
        ② text-overflow：设置或检索当前行超出容器边界如何显示
        ③ text-decoration：设置文字内部样式
        ④ text-shadow：设置文字阴影
    (4) 颜色：
        ① rgba：rgb 为颜色，a 为透明度
        ② hsla：h 为色相，s 为饱和度，l 为亮度，a 为透明度
3、transition：过度
4、transform
5、animation
6、渐变：
    (1) linear-gradient：线性渐变
    (2) radial-gradient：径向渐变
7、flex 布局
```

- align-items 和 align-content 的区别

```text
1、align-items：适用于所有的 flex 容器，设置 flex 子项在每个 flex 行的交叉轴上的对齐方式，
    可设置 flex-start、flex-end、center、stretch、baseline
2、align-content：只适用于多行的 flex 容器，当 flex 容器在交叉轴上有多余的空间时，将子项作为一个整体，
    可设置 flex-start、flex-end、center、stretch、space-ground、space-between
```

- CSS预处理器/后处理器是什么？为什么要使用它们？

```text
1、CSS 预处理器：
    (1) 是什么：
        ① 由于 CSS 本身不是编程语言，所以缺少编程语言的特性，导致开发维护较为困难，CSS 预处理器给 CSS 赋予一些简单的编程语言的特性，让开发者在日常开发中可以更高效的进行开发
    (2) 有什么：
        ① Less
        ② Sass
        ③ Stylus
2、CSS 后处理器：
    (1) 是什么：
        ① 由于 CSS 不确定会被运行在那个版本的浏览器上，导致不同版本的浏览器对 CSS 具有兼容性问题，通过给 CSS 添加前缀，做兼容性处理
    (2) 有什么：
        ① postCss：给 CSS 样式添加前缀，做兼容性处理
```

- 双边距重叠问题（外边距重叠）

```text
1、出现原因：多个相邻普通流的块元素垂直外边距会合并
2、出现效果：
    (1) 都是正数：折叠结果取较大值
    (2) 都是负数：折叠结果取绝对值较大值
    (3) 一正一负：折叠结果两者相加的和
```

- 单行、多行文本溢出隐藏

```css
/*1、单行：*/
div {
	/*溢出隐藏*/
	overflow: hidden;
	/*溢出用省略号显示*/
	text-overflow: ellipsis;
	/*规定段落中的文本不进行换行*/
	white-space: nowrap;
}

/*2、多行*/
div {
	/*溢出隐藏*/
	overflow: hidden;
	/*溢出用省略号显示*/
	text-overflow: ellipsis;
	/*作为弹性伸缩盒子模型显示。*/
	display: -webkit-box;
	/*设置伸缩盒子的子元素排列方式：从上到下垂直排列*/
	-webkit-box-orient: vertical;
	/*显示的行数*/
	-webkit-line-clamp: 3;
}
```

- z-index属性在什么情况下会失效
```text
1、父元素 position 为 relative 时，子元素的 z-index 无效，解决方法：父元素 position 改为 absolute 或 static
2、元素没有 position 属性或是 position 属性为 static，解决方法：设置元素 position 属性为 非 static
3、元素在设置 z-index 的时候还设置了 float 浮动，解决方法：去掉 float，改用 display：inline-block
```
- CSS布局单位
```text
1、px
2、rem
3、em
4、%
5、vh
6、vw
```
- offset/scroll/client/page 各类属性
```text
1、X、Y：
    (1) client：clientX、clientY
        ① 鼠标相对于浏览器窗口的相对 X、Y 坐标，表示页面可视区域的偏移量，可视区域不包括工具栏、搜索栏和滚动条等，并且与屏幕滚动无关，滚动后 Y 值不变
    (2) page：pageX、pageY
        ① 类似 client，但是 page 使用文档坐标而非窗口坐标，页面坐标 pageY = clientY + 页面滚动高度
    (3) offset：offsetX、offsetY
        ① 鼠标相对于事件源元素（srcElement）的 X、Y 坐标
    (4) screen：screenX、screenY
        ① 用来获取鼠标到屏幕显示器的距离，距离的最大值根据屏幕的分辨率尺寸来计算
    (5) scroll：scrollX、scrollY
        ① scrollX：表示 document 在水平方向上滚动的距离
        ② scrollY：表示 document 在垂直方向上滚动的距离
2、Height、Width、Top
    (1) client：clientHeight、clientWidth
        ① 包括 padding，但是不包括 border、水平滚动条、垂直滚动条、margin，对于 inline 元素都是 0，单位 px
        ② clientHeight = CSS height + CSS padding - 水平滚动条（如果有）
        ③ clientWidth = CSS width + CSS padding - 数值滚动条（如果有）
    (2) offset：offsetHeight、offsetWidth、offsetTop
        ① 包括 padding、border、水平滚动条、数值滚动条，但是不包括 margin 的元素高度，不包含伪元素如：::before、::after 的宽高，对于 inline 元素一直为 0，单位 px
        ② offsetHeight = CSS Height + CSS Padding + 水平滚动条高度（如果存在）
        ③ offsetWidth = CSS Width + CSS Padding + 数值滚动条（如果存在）
        ④ offsetTop：当前元素顶部 border 外层距离最近父元素内容顶部的距离，于滚动条无关
    (3) scroll：scrollHeight、scrollWidth、scrollTop
        ① 表示实际内容的高度。在没有滚动条的时候 scrollHeight === clientHeight，scrollWidth === clientWidth，包括元素 padding，不包括 border、margin。包括伪元素的宽高
        ② 有滚动条的情况下：scrollHeight、scrollWidth = 子元素宽高 + 当前元素 padding
        ③ 有滚动条时，滚动条向下滚动的距离，也就是被元素顶部遮住的高度，在没有滚动条的时候 scrollTop === 0，该元素可读可写
```

### 第三部分

- 用css画个三角形
- 实现一个扇形
- 画一条 0.5px 的线
- 移动端1px的问题
- 常见布局
    - 两栏布局
    - 等宽布局
    - 九宫格布局
    - 全屏布局
    - 圣杯布局 （三栏布局）
    - 双飞翼布局

### 第四部分

- 一个满屏品字布局如何设计
- 实现等腰梯形
- 实现一个点击之后从中心旋转并放大的正方形
- 实现一个宽高自适应的正方形
- css实现垂直水平居中，尽可能多的方案
- 三栏布局以及怎么实现三列等高
- 实现动画，元素先向右移动200px，再返回原点，一共移动n次（animation添加两个属性即可）
- 实现单行文本在父元素中不换行, 溢出部分变成省略号形式
- 想要鼠标移过 a 标签更换一个颜色，怎么实现？我想链接被点击过后更改颜色呢？

```css
span {
	width: 100px;
	height: 100px;
	text-align: center;
	linght-height: 100px
}
```

