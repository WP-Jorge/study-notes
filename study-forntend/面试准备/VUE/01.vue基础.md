- Vue data 为什么是函数

```text
1、当一个组件被定义，data 必须声明返回一个出实数据对象的函数，因为组件可能被用来创建多个实例，如果 data 仍然是一个对象，则所有的实例对象公用这个 data 数据对象，导致一个 data 中的数据发生改变，则所有的实例对象中对应的数据也发生改变。通过提供 data 函数，每次创建一个新的实例后，可以调用 data 函数返回一个新的 data 对象，这样就避免了实例间数据污染的问题
```

- Vue 组件生命周期

```text
1、beforeCreate
	(1) 描述：
		① 在实例初始化之后（new Vue），数据观测（data observer）和 event/watcher 事件配置之前被调用。
		② 无法在此获取 data 中的数据
	(2) 最佳实践：
		① 常用于初始化非响应式变量
2、created
	(1) 描述：
		① 此时完成了数据观测以及事件的初始化，此时可以获取到 data 中的数据
		② $el 属性目前不可见，DOM 还未挂载（DOM 还未通过 Vue 模板的编译，还是原 DOM，如 v-for 还在 DOM 中）
	(2) 最佳实践
		① 常用于简单的 AJAX 请求，页面的初始化
3、beforeMount
	(1) 描述：
		① 在挂载开始之前被调用，相关的（渲染函数）模板首次被调用
		② $el 属性可见，但是此时还是无法获取通过挂载模板生成的 DOM（如 v-for 还在 DOM 中）
		③ 在此函数之前都没有建立虚拟 DOM
		④ 服务端渲染不支持该钩子函数
4、mounted
	(1) 描述：
		① 执行完 beforeMount 函数后，$el 被新创建的 vm.$el 替换，并挂载到实例上，之后调用该钩子函数
		② 在此可以获取到渲染完成的 DOM 元素（v-for 渲染出来的 DOM）
		③ mounted 不会保证所有的子组件也都一起被挂载，如果想等到整个视图都渲染完毕，可以在 mounted 中使用 vm.$nextTick，（nextTick 在服务端渲染期间不被调用）
		④ 服务端渲染不支持该钩子函数
	(2) 最佳实践：
		① 常用于获取 VNode 信息和操作，AJAX 请求
5、beforeUpdate
	(1) 描述：
		① 数据更新时调用，发生在虚拟 DOM  打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
		② 该钩子在服务端渲染期间不会被调用，因为只有初次渲染会在服务端进行
	(2) 最佳实践
		① 适合在更新之前访问现有的 DOM，比如手动移除已经添加的事件监听器
6、updated
	(1) 描述：
		① 组件数据更新之后，由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
		② 当这个钩子被调用时，组件的 DOM 已经更新，所以可以执行依赖 DOM 的操作
		③ 大多数情况下，应该避免在此期间改变状态，如果要相应状态改变，通常最好使用计算属性或 watcher 来代替
		④ updated 不会保证所有子组件也都一起被重绘或重排，如果想要在此获取到渲染完毕的视图，可以使用 vm.$nextTick（nextTick 不会在服务端渲染期间调用）
7、activited
	(1) 描述：
		① keep-alive 专属，组件被激活时调用
		② 该钩子在服务端渲染期间不会被调用
8、deactivated
	(1) 描述：
		① keep-alive 专属，组件被销毁时调用
		② 该钩子在服务端渲染期间不会被调用
9、beforeDestory
	(1) 描述：
		① 实例销毁之前调用
		② 在这一步，实例依然完全可用
		③ 该钩子在服务端渲染期间不会被调用
	(2) 最佳实践：
		① 常用于销毁定时器、解绑全局事件、销毁插件对象等操作
10、destoryed
	(1) 描述：
		① 实例销毁后调用
		② 该钩子被调用后，对应 Vue 实例所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁
		③ 该钩子在服务端渲染期间不会被调用
```

- 路由生命周期

```text
1、三种生命周期：
	(1) 全局：
		① router.beforeEach
		② router.beforeResolve
		③ router.afterEach
	(2) 单个路由独享：
		① beforeEnter
	(3) 组件级：
		① beforeRouteEnter
		② beforeRouteUpdate
		③ beforeRouteLeave
2、全局前置守卫（router.beforeEach）
	(1) 格式：router.beforeEach((to, from, next) => {})
	(2) 描述：当一个盗汗触发时，全局前置守卫会按照创建顺序调用。守卫是异步解析执行，此时盗汗在所有守卫 resolve 完之前一致处于等待中
	(3) 参数：每个守卫方法都有三个参数
		① to:Route：即将要进入的目标路由对象
		② from:Route：当前导航正要离开的路由
		③ next:Function：一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数：
			Ⅰ next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confrimed（确认的）
			Ⅱ next(false)：中断当前导航。如果浏览器的 URL 改变了（可能是用户手机或者浏览器后退键），那么 URL 地址会重置到 from 路由对应的地址
			Ⅲ next('/') 或者 next({path: '/'})：跳转到一个不同的地址。当前的导航被中断，然后进行新的一个导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项
			Ⅳ next(error)：如果传入 next 的参数是一个 Error 实例，则导航会被种植且该错误会被传递给 router.onError() 注册过的回调
3、全局解析守卫（router.beforeResolve）
	(1) 与全局前置守卫（router.beforeEach）类似，区别在于导航被确认之前，同时在所有的组件内守卫和异步路由组件解析之后，解析守卫就被调用
4、全局后置钩子（router.afterEach）
	(1) 与守卫不同的是，这些钩子不会接收 next 函数参数，函数不会改变导航本身
5、路由独享守卫（route.beforeEnter），写在 routes 中，与全局前置守卫的参数一样
6、组件内守卫（在组件内直接定义路由导航守卫）
	(1) beforeRouteEnter：入参跟全局前置守卫一样
		① 在渲染该组件对应路由 confirm 前调用，也就是进入新的组件时调用
		② 不能获取组件实例的 this，因为当守卫执行前，组件实例还未被创建
	(2) beforeRoteUpdate：入参跟全局前置守卫一样
		① 在当前路由改变，但是该组件被复用时调用，如一个带有动态参数的路径：/foo/:id，在/foo/1 和 /foo/2 之间跳转的时候调用
		② 一样用来提示用户还未保存修改前突然离开
		③ 可以获取组件实例 this
	(3) beforeRouteLeave：入参跟全局前置守卫一样
		① 导航离开该组件的对应路由时调用
		② 可以访问组件实例 this
7、完整的导航解析流程
	(1) 导航被触发
	(2) 在失活的组件里调用离开守卫
	(3) 调用全局的 beforeEach 守卫
	(4) 在重用的组件里调用 beforeRouteUpdate 守卫
	(5) 在理由配置里调用 beforeEnter
	(6) 解析异步路由组件
	(7) 在被激活的组件内调用 beforeRouteEnter
	(8) 调用全局的 beforeResolve 守卫
	(9) 导航被确认
	(10) 调用全局的 afterEach 钩子
	(11) 触发 DOM 更新
	(12) 用创建好的实例调用 beforeRouteEnter 守卫传给 next 的回调函数
```

- Vue 修饰符

```text
1、表单修饰符
	(1) .lazy：给 v-model 加上 .lazy 修饰符，当用户输入完所有的东西后再触发数据更新（只有光标离开输入框的时候才会触发更新）
	(2) .trim：给 v-model 加上 .lazy 修饰符，过滤输入数据前后的空格
	(3) .number：给 v-model 加上 .number 修饰符，限制输入数字或者输入的东西转换成数字
		① 如果开始就输入数字，则限制输入只能为数字
		② 如果开始输入字符串，再输入数字，则相当于没有添加这个后缀
2、事件修饰符（修饰符可以多个同时使用，但是会根据先后顺序依次执行，造成效果的不同）
	(1) .stop：给 @ 后面的事件加上 .stop 修饰符，相当于阻止事件冒泡，相当于使用了 event.stopPropagation() 方法
	(2) .prevent：给 @ 后面的事件加上 .prevent 修饰符，用来阻止事件的默认行为，如 当剪辑提交按钮的时候阻止对表单的提交，相当于调用了 event.preventDefault() 方法
	(3) .self：给 @ 后面的事件加上 .self 修饰符，只当事件是从事件绑定的元素本身触发时才会触发回调
	(4) .once：给 @ 后面的事件加上 .once 修饰符，对所修饰的事件只执行一次，第二次往后不会执行
	(5) .capture：给 @ 后面的事件加上 .capture 修饰符，事件触发从包含这个元素的顶层开始向下触发
	(6) .passive：给 @ 后面的事件加上 .passive 修饰符，当监听元素滚动事件的时候，会一直触发 onscroll 事件，在 pc 端没有问题，但是在 移动端，网页会卡顿，因此使用这个修饰符，相当于给 onscroll 事件整了一个 .lazy 修饰符
	(7) .native：给 @ 后面的事件加上 .native 修饰符，对于组件的行内事件如 <My-component @click="shout(3)"></My-component>，shout 函数不会被触发，当给 @click 添加上 .native 后才会被触发。可以理解为该修饰符把一个 vue 组件转化为普通分 HTML 标签，但是普通的 HTML 标签加上这个修饰符会使事件失效
3、鼠标按钮修饰符：改变 click 事件的事发按键
	(1) .left 左键触发
	(2) .right 右键触发
	(3) .middle 中间键触发
4、键值修饰符：如果不用 keyCode 修饰符，那么每次按下键盘都会触发方法，如果只想按下某个按键时才会触发事件，可以使用这个修饰符，vue 一般有给常见的键取了别名（如果只使用 keyCodes 修饰符，无法触发 keyup 事件，需要通过与 @keyup 事件同用才能触发，如 @keyup.ctrl.67="sout()"）
	(1) .enter
	(2) .tab
	(3) delete // 捕获删除、退格键
	(4) space
	(5) esc
	(6) up
	(7) down
	(8) left
	(9) right
	系统修饰键
	(10) ctrl
	(11) alt
	(12) meta
	(13) shift
	(14) 可通过全局 config.keyCodes 对象自定义案件修饰符别名：
		Vue.config.keyCodes.f1 = 112
	(15) exact：如 @click.ctrl="sout" 意思是按下 ctrl再单击才会触发，但是如果同时还按了如 shift，也会触发。加上 exact 后解决这个问题，如 @click.ctrl.exact="shout(4)"
5、v-bind 修饰符
	(1) .sync：实现组件中 props 数据的双向绑定
		① 使用 sync 的时候，子组件传递的事件名必须为 update:value，其中 value 必须与子组件中 props 中声明的名称完全一致(如上例中的 myMessage，不能使用 my-message)
		② 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync="doc.title + '!'" 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model
		③ 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync="{ title: doc.title }"，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑
	(2) .prop：通过自定义属性存储变量，避免暴露数据，防止污染 HTML 结构
		① 如果只是用 v-bind，则属性会被绑定到 节点上的 attribute（特性）上，使用 .prop 修饰后则会变成节点的 property（属性）上
		② 特性通过 结点.attribute.特性 获取，或者通过 结点.getAttribute(特性) 获取
		③ 属性通过 结点.属性 获取
	(3) .camel：HTML 文档忽略大小写，<svg :viewBox="viewBox"></svg> 会被渲染成 <svg viewbox="viewBox"></svg>，这将导致 SVG 失效，因为 SVG 只认 viewBox，想让 viewbox 渲染成驼峰，就使用 .camel 修饰
```

- 阻止事件冒泡的 API
```text
1、IE：event.cancelBubble = true
2、主流浏览器：Event.stopPropagation()
```
- 组件间怎么通信
```text
1、父子组件通讯：
	(1) props/emit
	(2) parent/children
		① 子组件可以使用 this.$parent 来获取父组件，如果没有父组件，这个父组件将会是自己
		② 父组件可以通过 this.$children[index] 来获取相应 index 的子组件，this.$children 是直接子组件的集合
	(3) provide/inject（可以是多级父子组件，如祖父组件和玄孙组件）
		① 父组件中通过 provide 提供变量
		② 子组件中通过 inject 获取父组件提供的变量
2、任意组件通讯：
	(1) ref/refs
		① ref：如果再普通的 DOM 元素上使用，引用指向的就是 DOM 元素，如果是在子组件上使用，引用的就是组件实例，可以通过实例直接调用组件的方法或访问数据
		② refs：在想要获取 ref 的的地方使用 this.$refs 来获取 ref 标记的实例
	(2) eventBus 事件总线
		① 在 Vue 中可以作为沟通桥梁，就像是所有组件公用的相同的事件中心，可以向该中心注册发送事件或接收事件
		② 如果在大型项目中使用会造成项目难以维护
	(3) Vuex
	(4) localStorage/sessionStorage

```
- v-if 和 v-show 区别
```text
1、v-if：
	① 首次渲染，如果条件为假，什么也不操作，DOM 中没有该元素，当条件为真的时候，动态的向 DOM 元素里面添加元素，当条件由真变为假的时候，开始局部编译，卸载这些元素。所以切换开销较大
	② 有配套的 v-else-if、v-else，用法与 JS 的用法基本一致
	③ 可以作用在 <template> 标签上

2、v-show：
	① 不管条件是真还是假，都会被编译出来，标签都会添加到 DOM 中，之后切换的时候通过 display: none 来显示隐藏元素，只通过改变 CSS 样式，切换性能开销小
	② v-show 不支持作用在 <template> 标签上
```
- vue-router 的两种模式以及区别
```text
1、hash 模式：
	(1) 通过地址栏 # 号后的 hash 进行路由跳转
	(2) hash 虽然出现在 URL 中，但是不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面
2、history 模式：
	(1) 利用 H5 中新增的 pushState()、replaceState() 方法进行页面跳转
	(2) 这两个方法应用于浏览器的历史历史记录栈，在当前已有的 back、forword、go 的基础上，提供了对历史记录进行修改的功能，只是当他们进行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求
	(3) 当用户手动输入 URL 后回车、刷新浏览器时：
		① hash 模式下。仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到路由的全覆盖，也不会返回 404
		② history 模式下，前端的 URL 必须和实际向后端发起请求时的 URL 一致，如果后端缺少对该路由的处理，就会返回 404，要想不报 404，就要在服务端上增加一个覆盖所有情况的候选资源，如果 URL 匹配不到任何静态资源，则应该返回一个 index.html 页面，这个页面就是项目 app 的初始页面
```
- 页面打开要渲染一个列表的数据，在哪个声明周期请求数据
```text
1、越早越好，只要 data 被渲染完成，就可以请求数据，所以可以放在 created 中
```
- vue 组件初始化的时候，有多种方式 new complete 和 exports，他们的 data 字段有什么区别？
```text
1、在 Vue 实例中可以使用 对象的形式，也可以是函数的形式返回一个对象
2、在组件中只能使用函数的形式返回一个对象
```
- 有没有写过公共组件，如何去实现
```text
1、抽离公共部分
2、变化大的地方使用插槽占位
3、确定需要的参数
```
- computed 和 watch 的区别
```text
1、computed：
	(1) 计算属性基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到一个新值，这个新值只会根据已知值的变化而变化
	(2) 带有缓存功能，多次使用同一个计算属性则只进行一次计算，并将其值进行缓存，并且当且仅当 data、props 中的数据发生变化时才调用
	(3) 用来处理复杂的逻辑运算，一个数据受一个或多个数据影响，用来处理 watch 和 methods 无法处理的，或处理起来不方便的情况。例如处理模板中的复杂表达式，购物车里面的商品数量和总金额之间的变化关系等
2、watch：
	(1) 监听 Vue 实例上属性变化，或某些特定数据的变化，然后执行某些具体的业务逻辑操作。当属性变化时，回调函数自动调用，在函数内部进行计算
	(2) 可以监听复杂数据类型并进行深层次的监听
	(3) 用来处理当一个属性发生变化是，需要执行某些具体的业务逻辑操作，或要在数据变化时执行异步或开销大的操作。一个数据改变影响多个数据，如监听 input 输入框的特殊处理
```
- vue 编译过程
```text
1、先初始化各种属性
	(1) initLifecycle(vm)：初始化生命周期函数
	(2) initEvents(vm)：初始化事件
	(3) initRender(vm)：初始化处理渲染模板的函数
	(4) callHook(vm, beforeCreate)：执行 beforeCreate 函数
	(5) initInjections(vm)：初始化 inject before data/props
	(6) initState(vm)：初始化 props、methods、data、computed、watch
	(7) initProvide(vm)：初始化 provide after data/props
	(8) callHook(vm, created)：执行 created 函数
2、拿到 #app 对应的 dom 代码字符串
	(1) template = getOuterHTML(el);
		① template 打印出来是："<div id="app"> {{aa}} --- 1 <div @click="qqq">click me</div> {{C_aa}} </div>"
3、编译 template 生成 ast 树和匿名渲染函数
	(1) let compiled = compile(template, options);
		① 得到 ast 树
		② 得到匿名渲染函数：createFunction(compiled.render, fnGenErrors)
4、callHook(vm, 'beforeMount')：执行 beforeMount 函数
5、执行 vm._update(vm._render(), hydrating)：（关键函数）渲染/更新 函数
	(1) 先执行 vm._render()，通过执行匿名渲染函数，得到虚拟 dom 树 vnode
		① 虚拟 dom 树 vnode 是用 js 对象去标识 dom树
		② 操作 js 要比操作真实 dom 性能搞很多，特别是做新旧 vnode 之间的 diff 算法的时候
	(2) 在执行 vm._update()，层层递归虚拟 dom 的 vnode，得到真正的 dom 结点，然后 update 到真正的 dom 树上，然后浏览器渲染出最新的 dom 树
6、callHoock(vm, 'mounted)：执行 mounted 函数，此时真实的 dom 树已经好了，可以获取到 dom 元素
7、调用结束

```
- vue router 和 route 的区别
```text
1、route：当前激活的路由的信息对象，每个对象都是局部的，可以获取当前路由的 path、name、params、query 等属性
2、router：全局的 router 实例，通过 vue 根实例注入 router 实例，然后再注入到美分子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（如 history 对象），任何页面也哦都可以调用其 push()、replace()、go() 等方法
```
- ref 和 reactive
```text
1、ref：
	(1) 将一个原始数据类型转换为一个带有响应式热心发的数据类型，原始数据类型有：String、Number、BigInt、Symbol、Null、Undefined
	(2) 模板默认调用 value 显示数据，方法中需要使用 属性名.value 来显示、修改数据
	(3) ref 的本质就是通过 reactive 创建的 ref(10) => reactive({value: 10});
2、reactive：
	(1) 用来创建引用类型的响应式数据：reactive({value: 10});
	(2) reactive 再模板中必须写全，不能省略 .value，不然显示整个数据
	(3) reactive 的本质就是迹象每一层的树都解析成 proxy 对象，reactive 的响应式默认都是递归的，改变某一层的值都会递归的调用一边，重新渲染 dom
3、shallowRef：
	(1) 创建非递归的响应对象，调用时需要加上 .value
4、shallowReactive：
	(1) 创建非递归的响应对象，只有第一层的数据才是响应式的

```
- vue3 的 composition api 推出的目的是什么（有什么好处）
```text
1、由于在 vue2 中：
	(1) 代码的可读性随着组件的变大而变差
		① 所有的 data、methods 等都放在一个 .vue 文件中，在开发过程中 .vue 文件越来越大，要想找到其中的一个功能点，需要耗费较多时间
	(2) 每一种代码的复用方式都存在缺点
		① mixins：
			Ⅰ 存在冲突隐患，如出现属性、函数名冲突
			Ⅱ 依赖不清晰，特别是多个 mixins 存在交流的情况下
			Ⅲ 逻辑复用不够灵活，如果你在需要不同的组件间差异化或配置话使用的话，做不到
	(3) TS 支持有限
2、Composition API：
	(1) 可将所有同一功能的代码写在同一个区域里，大大提高维护性、可读性
	(2) 通过对复用代码的抽离，可对复用的逻辑进行随意的组合、配置，并放入 setup 函数中执行
```
- vue3.0 了解吗？他的特性
```text
1、Tree-shaking
	(1) 通过对所有 api 使用 es6 模块化的方式引入，在打包过程中对没有使用的 api 进行提出，最小化 bundle 体积
2、生命周期函数
	(1) 新增了一个 setup 生命周期函数，setup 执行的时机是在 beforeCreate 生命周期函数之前执行，因此这个函数中不能使用 this 获取实例，为了命名统一，将 beforeDestory 改名为 beforeUnmount，destoryed 改名为 unmounted，因此 vue3 有以下生命周期函数：
		① beforeCreate（建议使用 setup 替代）
		② created（建议使用 setup 替代）
		③ setup
		④ beforeMount
		⑤ mounted
		⑥ deforeUpdate
		⑦ updated
		⑧ beforeUnmount
		⑨ unmounted
	(2) vue3 新增了生命周期钩子，可以通过在生命周期函数前加 on 来访问组件的生命周期：
		① onBeforeMount
		② onMounted
		③ onBeforeUpdate
		④ onUpdated
		⑤ onBeforeUnmount
		⑥ onUnmounted
		⑦ onErrorCaptrued
		⑧ onRenderTracked
		⑨ onRenderTriggered
3、响应式 API（替换 Vue2 中的 defineProperty，使用 Proxy 实现响应式，解决前者无法监听数组下标变化的响应式等）
	(1) ref
	(2) reactive
	(3) 等
4、响应式监听
	(1) watch（与 Vue2 中的用法差别不大）
	(2) awtchEffect
		① watchEffect 不需要手动传入依赖
		② 每次初始化时 watchEffect 会执行一次回调函数自动获取依赖
		③ watchEffect 无法获取原值，只能得到幻化后的值
		④ watchEffect 会在页面加载时自动执行一次，追踪响应式依赖，在加载后定时器每隔 1s 执行时，watchEffect 都会监听到数据的变化自定执行，每次执行都是获取到变化后的值

5、Composition Api（组合 API）
6、Fragment
	(1) Vue 模板中可以无需一个根结点，用一个虚拟的 fragment 来替代 div
7、Teleport
	(1) 可将组件、元素传送到指定的标签下
8、等等
```
- vue3.0 的 proxy 解决了什么问题
```text
1、defineProperty：
	(1) 检测不到对象属性的添加和删除
	(2) 数组下标变化无法监听到
	(3) data 中数据比较多且层次很深时，会有性能问题，因为需要遍历 data 中所有的属性并给其设置成响应式
2、Proxy：
	(1) 直接劫持整个对象，并返回一个新的对象，可以之操作新的随想来达到响应式目的，同时由于不是通过遍历实现响应式，性能上有较大提升
	(2) 可以监听到数组下边的变化
```
