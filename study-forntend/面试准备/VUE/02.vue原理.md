- 讲讲 window.history 的原理，为什么 popstate 能够实现前端路由
```text
1、history 使用了 H5 中的 history 新增的两个 API：pushState、replaceState
	(1) 两个 API 都接受三个参数：
		① 状态对象（state object）：一个 JS 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件都会触发，且该事件的 state 属性包含该历史记录条目状态对象的副本
		② 标题（title）：浏览器目前忽略这个参数
		③ 地址（URL）：新的历史记录记录的地址。浏览器调用 pushState() 方法后并不会立即加载该地址，但可能会在稍后某些情况下加载这个 URL，比如用户重启浏览器。新的 URL 不一定是绝对路径，如果是相对路径，它将以当前的 URL 为基准，传入的 URL 与当前 URL 应该是同源的，否则 pushState() 会抛出异常。该参数是可选的，不指定的话则为当前的 URL
	(2) 相同之处：两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于 pushState 会新增一条新的历史记录，而 replaceState 则会替换当前的历史记录
	(3) popstate 事件：;
		① window 的一个事件，当点击前进或者后退按钮时触发
		② history 对象调用 back、forword、go 方法触发
		③ pushState、replaceState 不会触发
```
- hash 路由原理
```text
1、hash：
	(1) hash 只作用在浏览器。不会在请求中发送给服务器
	(2) hash 发生改变，浏览器并不会重新给后端发送请求加载页面
	(3) 修改 hash 时会在浏览器留下历史记录，可以通过浏览器返回按钮回到上一个页面
	(4) hash 发生变化时会触发 hashchange 事件，在该事件中可以通过 window.location.hash 获取到当前的 hash 值
```
- vue2 响应式原理
- vue3 响应式原理
- vue 双向绑定。要求手撕简单版。（去 b 站搜尤雨溪的视频看，学会那里面的简易版 demo，以后面试就手撕这个 demo，保证比你嘴巴强）
- vue 改变数组中的值 vue 怎么监听到的
```text
1、重写数组方法：pop、push、shift、unshift、sort、resolve、splice
2、$set，内部本质上还是使用上面重写的数组方法对数组进行响应式更新
```
- vue 的 v-model 的原理
```text
1、v-bind 绑定数据
2、监听 iuput 事件，当数据更新时调用 update 事件，更新响应式依赖到数据
```
- 详细说一下 vue3 composition api
- vue 单向数据流的特点
```text
1、父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值
2、子组件无法直接修改 prop 来更新父组件数据
```
- vue 的 keep-alive 原理
```text
1、是什么：keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们
```
- call、apply、bind 的使用场景
- this.$nextTick 原理
- V-model 原理
```text
1、v-model 本质上是语法糖，v-model 在内部位不同的输入元素使用不同的属性并抛出不同的事件
	(1) text/textarea 元素使用 value 属性 和 input
	(2) checkbox/radio 元素使用 ckecked 属性和 change 事件
	(3) select 元素将 value 作为 prop 并将 change 作为事件
```
- nextTick 原理
- $nextTick 为什么在回调函数中可以获得那个 DOM 节点
- Vue 使用 nextTick 的原因和作用，项目哪些场景用到了 nextTick
- 有了解 vuex 具体如何通知到其他组件的更新吗
- AST 了解吗？
- diff 算法
- v-for key 原理
- 虚拟 DOM 怎么实现
- 为什么要用 Virtual Dom
- Virtual Dom 的效率一定比直接操作 Dom 高吗
- 是数组的话 vue 怎么监听其变化的
