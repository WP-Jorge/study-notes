- 深拷贝、浅拷贝的区别

```text
1、浅拷贝：只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是公用同一块内存，修改新对象会同步修改原对象
2、深拷贝：会创建一个与原对象一模一样的新对象，新对象跟原对象不共享内存，修改新对象不会影响到原对象
```

- 实现深拷贝，要求考虑到对象， 数组， Date， 正则和函数
- 防抖 / 节流概念区分，手写其实现
- 手写 Promise.all()
- 手写 Promise.any()
- 手写 Promise.race()
- 手写 promise
- 手写 new
- 通过 new 构造函数创建实例对象，在构造函数上声明一个方法，跟直接给实例对象声明一个方法有什么区别吗？

```text
1、在构造函数上声明一个方法，那么这个函数通过 new 构造出的函数实例对象也能使用这个方法
2、如果直接给实例对象声明一个方法，那么这个方法是能这个实例对象使用，它的原型再实例化一个新的对象则不能使用这个方法
```

- 什么时候在原型上声明方法，什么时候给实例对象声明方法？

```text
1、如果只想让这个实例使用这个方法，那么就在这个实例上声明方法
2、如果想让这个原型的所有实例都可以使用这个方法，那么就在这个原型生声明方法
```

- 手写 apply
- 手写 call
- 手写 bind
- 手写题：instanceof
- 手写题：typeof
- 手写一个判断类型方法（希望用 object.toString 方法）
- 封装 ajax
- async await 原理
- 怎么监听 DOM 变化
```js
/* 
1、使用 MutationObserver
2、特点：
	(1) 等待所有的脚本执行完成后，才会运行，即采用异步方式
	(2) 把 DOM 变动记录封装到一个数组中进行处理，而不是一条条的个别处理 DOM 变动
	(3) 可以观察发生在 DOM 节点的所有变动，也可以观察某一个变动 
*/
// 实现：
let mutationObserver = new MutationObserver((mutations, observer) => {
	console.log(mutation, observer);
});
let el = document.querySelector('#app');
let options = {
	childList: true,
	attributes: true
};
mutationObserver.observer(el, options);
```
