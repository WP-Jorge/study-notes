- js 数据类型有哪些

```text
1、最新的 ECMA 定义了8种数据类型：
	(1) 7种基础数据类型：number，string，boolean，undefined，null，bigint，symbol
	(2) 1种引用数据类型：Object
```

- js 类型判断

```text
1、type of
2、instanceof
3、Object.prototype.toString.call(obj)
4、Array.isPrototypeOf(arr)
```

- 怎么区别 array 和 object

```text
1、Array.isArray(obj)
2、obj instanceof Array
3、Object.prototype.toString.call(obj)
4、obj.__proto__.constructor
```

- let、const 区别，const 声明了数组，还能 push 元素吗，为什么？

```text
1、let 和 const 都不具有变量提升，都具有块级作用域，都具有暂时性死区的问题
2、let 声明的变量地址可以改变，const 声明的变量地址不可以改变
3、const 在声明变量的时候必须赋初始值，不然会报错
4、由于使用 const 声明的数组的地址没有改变，所以可以使用push
```

- 说说你经常使用到的 array 方法，类数组怎么转换为数组，说说你知道的所有方法

```text
1、常用的 array 方法：splice，slice，push，pop，shift，
        unshift，indexOf，lastIndexOf，includes，map，reduce，
        filter，forEach，every，some，
        sort，find，entries，values，keys，flat
2、类数组使用 Array.from(类数组)，扩展运算符[...类数组]，new Array[...类数组]
```

- DOM 怎么添加事件

```text
1、dom.addEventListener('事件名称', '回调函数');
2、dom.on事件名称 = 函数;
```

- this 指向

```text
1、在函数中的 this 指向 window
2、在对象中的方法 this 指向调用这个方法的对象
3、在类中或通过 new 生成的实例对象，this 指向这个实例
4、箭头函数中的 this 指向这个箭头函数所在的上下文
5、箭头函数中的 this 在箭头函数定义时就进行绑定，而不是在使用时进行绑定
6、箭头函数的 this 不能通过 bind、call、apply 进行变换
```

- 可枚举属性和不可枚举属性

```js
Object.defineProperty(obj, {
	enumerable: false // false 不能枚举（默认）, true 可枚举
})
```

- ES6 导入和 commonJS 区别

```text
1、commonJS 导入是同步的，在导入时会阻塞下面的代码执行，输出的是对一个值的浅拷贝，运行时加载
2、ES6 js引擎对脚本进行静态分析的时候，遇到 import 时，会生成一个只读引用，等到代码真正执行时，再根据这个只读引用到被加载模块中取值
```

- common.js 和其他的模块机制？

- es6+ 特性

```text
1、箭头函数
2、Map、Set
3、let、const
4、class
5、async await
6、模板字符串
7、数组、对象解构
8、函数参数默认值
9、for of
10、Proxy
11、Reflect
12、ES 6 module
```

- 讲讲什么是闭包

```text
1、在一个内层函数中可以访问外层函数的作用域，这就是闭包
2、闭包可以延长变量作用域，但是会造成内存泄漏
```

- 数组去重有哪些方式

```js
// ① 使用 set
let arr = [1, 4, 1, 2, 4, 5];
let set = new Set(arr);
let argetArr = [...set];
console.log(argetArr); // [1, 4, 2, 5]

// ② 排序后去重
let arr = [1, 4, 1, 2, 4, 5];

function func(arr) {
	arr.sort((a, b) => {
		return a - b;
	})
	let newArray = [];
	for (let i = 0; i < arr.length; i++) {
		if (!newArray.includes(arr[i])) {
			newArray.push(arr[i])
		}
	}
	return newArray;
}

func(arr);
```

- 如何遍历对象的值

```js
// ① 使用 for in
let obj = {
	a: 1,
	b: 2,
	c: 3
}

for (let key in obj) {
	console.log(obj[key]);
}
// ② 使用 Object.keys()
Object.keys(obj).map(item => {
	console.log(obj[item]);
})
// ② 使用 Object.values()
Object.values(obj).map(item => {
	console.log(item);
})
// ② 使用 Object.entries()
Object.entries(obj).map(item => {
	console.log(item[1]);
})
```

- for of 能遍历对象吗

```text
不能，因为 对象中没有提供 iterator 接口
```

- for in 和 for of 的区别

```text
1、for in 可以用来遍历对象中可枚举属性，包括它的原型链上的可枚举属性
2、for of 可以用来遍历可迭代对象，如 Array，Set，Map
```

- for in 的缺点

```text
1、不能用来遍历不可迭代对象
2、在遍历对象的时候会遍历到这个对象的原型上的可迭代属性
3、迭代顺序依赖于执行环境，不一定保证顺序
```

- for in 和 Object.keys() 的区别

```text
1、for in 用来遍历对象，会将这个对象原型上的可枚举属性也遍历出来
2、Object.keys() 用来获取对象的键名，不会获取到该对象原型上的属性
```

- proxy 的缺点优点

```text
1、优点：可以劫持整个对象，无需像 defineProperty 需要递归劫持，并返回一个新对象
    可以监听数组变化
2、缺点：只有支持 es6 的浏览器内核才能使用，具有兼容性问题
```

- Object.defineProperty 和 Proxy 区别

```text
1、Object.defineProperty：对于每个需要做数据劫持的属性都要进行 getter 和 setter 的设置，对于一个对象，则需要递归的将每个属性都进行设置，并且无法劫持使用数组操作以及下标来修改数组
2、Proxy：可以劫持整个对象，无需像 Object.defineProperty 需要递归劫持每个属性，Proxy 代理返回一个新的代理对象，可以对数组下标的变化进行监听，但是只能在支持 es6 的浏览器上使用，具有兼容性问题
```

- 垃圾回收机制

```text
1、引用计数：为每个变量都维护一个 count 计数，当 count 的数不为 0 时则说明这个变量被使用，当 count === 0 时，会在下一次的垃圾回收过程中被回收。缺点：如果存在循环引用，那个这个变量将一直不会被垃圾回收，造成内存泄漏
2、标记清除：在进入变量所在作用域的时候，会给所有的变量加上一个标记，然后将上下文中的被访问引用的变量去除标记。表示这些变量需要被使用，并在下一次的垃圾回收过程中被标记的变量被回收
```

- 数组去重，set 为什么不可重复原理

- 栈、堆内存

```text
1、js 内存分为 栈内存和堆内存
	(1) 栈：放基本数据类型，因为基本数据类型占用空间小，大小固定，通过值来访问
	(2) 堆：放复杂对象，由于引用数据类型占据空间大，大小不固定，如果将这些引用类型数据放在栈中，会影响程序的运行性能，这些引用数据类型还会在栈中存储一个引用指针，用来指向堆内存中的地址
```

- 怎么判断一个变量是一个数组？怎么判断一个变量是 null？

```js
// 判断是否是数组
Array.isArray(arr);
Object.prototype.toString.call(arr);
arr instanceof Array

// 判断是否是null
a === null
```

- symbol 介绍

```text
Symbol 是 es6 新增的基本数据类型，所生成的值具有唯一性，可作为对象的 key，使用 symbol 所定义的属性无法被枚举，可作为对象的私有属性
```

- set 和 map 的区别？

```text
1、set：成员唯一，无序不重复，是一组key的集合，可以遍历
2、map：以键值对的形式存储数据，具有极快的查找速度，允许任意类型的 key，可以遍历
```

- map 与 object 的区别？

```text
1、map:
	(1) 键名可为任意数据类型，Map 继承 Object，并对 Object 的功能做了扩展，map 键名具有同名碰撞，只要 key 的地址不一样，就是不同的键名，可以使用 for of 来遍历迭代
    (2) 有序性，插入 map 的元素会保持原有的顺序，具有 size 属性，可以拿到长度
2、object：键名只能为基本数据类型，属性顺序随机，不能通过 for of 访问
```

- map 和 weakmap 区别

```text
1、map：
	(1) 键名可为任意类型
    (2) 能被遍历
    (3) 键值对一直存在，不会被垃圾回收
2、weakmap：
	(1) 键名只能为引用数据类型，null不行
    (2) 不能被遍历
    (3) 当键名没有其他地方引用时会被垃圾回收
```

- map 和 object 的 key 遍历顺序是怎样的？

```text
1、Map：遍历顺序有序
2、Object：遍历时不保证对象属性的顺序
```

- 箭头函数和非箭头函数的区别

```text
1、箭头函数：
	(1) this 指向定义所在上下文
    (2) this 在箭头函数定义时就进行绑定，而不是在使用时进行绑定
    (3) this 不能通过 bind、call、apply 进行变换
    (4) 没有 arguments 属性
    (5) 不能被实例化
    (6) 没有原型属性 prototype
    (7) 不具有 super
2、非箭头函数：
	(1) 在对象方法上时 this 指向调用的对象
    (2) 可作为类被实例化
```

- Array.map some forEach，every 区别

```text
1、map：遍历数组，返回新数组，对数组中的每个元素进行相应操作
2、some：遍历数组，返回是否满足给定条件的Boolean值，只要有一个满足就返回
3、forEach：遍历数组，每个元素都会被遍历，没有返回值
4、every：遍历数组，若全部满足添加返回 true 否则返回 false
```

- js 实现千位分隔符？

```js
// ① 模拟实现
function getNumber(str) {
	let tempStr = (str + '').split('.');
	let partOne = tempStr[0];
	let partTwo = tempStr[1] ? tempStr[1] + '' : '';
	partOne = partOne.split('');
	let resArr = [];
	partOne.reverse();
	for (let i = 0; i < partOne.length; i++) {
		if (i !== 0 && i % 3 === 0) {
			resArr.push(',')
		}
		resArr.push(partOne[i]);
	}
	resArr.reverse()
	if (partTwo) {
		console.log(resArr.join('') + '.' + partTwo);
	} else {
		console.log(resArr.join(''));
	}
}

getNumber(711190.123456)

// ② 使用toLocalString()
num.toLocaleString();

// ③ 使用正则
function getNumber(str) {
	str += '';
	let tempArr = str.split('.');
	let partOne = tempArr[0];
	let partTwo = tempArr[1];
	let reg = /(\d)(?=(\d{3})+$)/g;
	let resStr = partOne.replace(reg, '$1,')
	if (partTwo) {
		return resStr += '.' + partTwo;
	}
	return resStr;
}

console.log(getNumber(711190.1244));
```

- 简单数据类型和复杂数据类型的区别？

```text
1、简单数据类型存放在栈内存中，存储是直接存储值本身
2、复杂数据类型存放在堆内存中，在栈中只存储在堆中的地址引用，对于赋值操作是直接将这个复杂数据类型的引用赋值给目标，故为浅拷贝
```

- 对于原型的理解

```text
1、js 是一种基于原型的语言，每个对象都有一个原型对象，对象以其原型作为模板，从原型上继承方法和属性，原型对象也可能拥有原型，并从中继承方法和属性。js 中的继承就是通过原型链的方式进行的
```

- 原型链继承和 class 区别

```text
1、原型链继承：当原型中出现引用值的时候，原型中包含的引用类型的属性会被子类继承，导致原型属性被子类篡改
2、class：子类既继承了原型上的属性和方法，还继承了实例属性，对比原型链继承，实现了
```

- 手写 7 种继承方式

```js
/**
 * ① 原型链继承
 * 缺点：多个实例对引用类型的操作会被篡改
 */
function Animal() {
	this.name = '动物';
	this.age = 1;
	this.types = ['cat', 'dog'];
}

function Cat() {
	this.name = '猫';
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
let cat = new Cat();
cat.types.push('fish');

console.log(cat);
console.log(cat.types); // ['cat', 'dog', 'fish']

let cat2 = new Cat();
console.log(cat2.types); // ['cat', 'dog', 'fish']

/**
 * ② 盗用构造函数继承
 * 缺点：只能继承父类的实例属性和方法，不能继承原型属性/方法
 *      无法实现复用，每个子类都有父类实例函数的副本，影响性能
 */
function Animal() {
	this.name = '动物';
	this.age = 1;
	this.types = ['cat', 'dog'];
}

Animal.prototype.eat = function () {
	console.log('eat something');
}

function Cat() {
	Animal.call(this);
	this.name = '猫';
}

let cat = new Cat();
console.dir(cat);
cat.types.push('fish');
console.log(cat.types); // ['cat', 'dog', 'fish']

let cat2 = new Cat();
console.log(cat2.types); // ['cat', 'dog']

// 只能继承父类的实例属性和方法，不能继承原型属性/方法
cat.eat(); // 报错

/**
 * ③ 组合继承
 * 缺点：每个子类实例都有父类实例的属性与方法，造成资源浪费
 */
function Animal() {
	this.name = '动物';
	this.age = 1;
	this.types = ['cat', 'dog'];
}

Animal.prototype.eat = function () {
	console.log('eat something');
}

function Cat() {
	Animal.call(this);
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;

let cat = new Cat();
console.dir(cat);
cat.types.push('fish');
console.log(cat.types); // ['cat', 'dog', 'fish']

let cat2 = new Cat();
console.log(cat2.types); // ['cat', 'dog']

cat.eat();

/**
 * ④ 原型式继承
 * 缺点：原型式继承多个实例的引用数据类型属性相同，存在篡改的可能
 *      无法传递参数
 */
// 创建一个新的构造函数，让这个新的构造函数的原型指向 obj，返回这个新的 构造函数的实例
function getSuperObj(obj) {
	function NewObj() {}

	NewObj.prototype = obj;
	return new NewObj;
}

let obj = {
	name: '张三',
	age: 19,
	friends: ['1']
};

// 对这个新的实例添加新功能
let newObj = getSuperObj(obj);
newObj.say = function () {
	console.log('你好');
}

// obj 的属性与方法都能使用
console.log(newObj.name); // 张三
console.log(newObj.age); // 18
newObj.say(); // 你好
newObj.friends.push('2');
console.log(newObj.friends); // ['1', '2']

// 原型式继承多个实例的引用数据类型属性相同，存在篡改的可能
let newObj2 = getSuperObj(obj);
newObj2.friends.push('3');
console.log(newObj2.friends); // ['1', '2', '3']

/**
 * ⑤ 寄生式继承
 * 缺点：原型式继承多个实例的引用数据类型指向相同，存在篡改的可能
 *      不能传递参数
 */
// 在原型式继承的基础上，增强对象，返回构造函数
function getSuperObj(obj) {
	function NewObj() {}

	NewObj.prototype = obj;
	return new NewObj;
}

// 函数的主要作用是为构造函数新增属性和方法，以增强函数
function getNewObj(obj) {
	let newObj = getSuperObj(obj);
	newObj.eat = function () {
		console.log('吃饭');
	}
	return newObj;
}

let obj = {
	name: '张三',
	age: 19,
	friends: ['1']
};

let newObj = getNewObj(obj);
newObj.eat(); // 吃饭

/**
 * ⑥ 寄生组合式继承
 */
function inheritPrototype(subObj, superObj) {
	let prototype = Object.create(superObj.prototype); // 创建父类原型的一个副本
	prototype.constructor = subObj; // 将丢失的构造函数重新赋值上
	subObj.prototype = prototype; // 将父类原型赋值给子类的原型
}

function Animal() {
	this.name = '动物';
	this.type = ['cat', 'dog'];
}

// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
function Cat() {
	Animal.call(this);
	this.name = '猫';
	this.eat = function () {
		console.log('吃鱼');
	}
}

// 将子类原型指向父类
inheritPrototype(Cat, Animal);

let cat = new Cat();
let cat2 = new Cat();

console.log(cat.name); // 猫
console.log(cat.type); // ['cat', 'dog']
cat.type.push('mouse');
console.log(cat.type); // ['cat', 'dog', 'mouse']
console.log(cat2.type); // ['cat', 'dog']
cat.eat(); // 吃鱼

/**
 * ⑦ class extends 继承
 * 原理：等同于寄生组合式继承
 */
class Animal {
	constructor() {
		this.name = '动物';
		this.type = ['cat', 'dog'];
	}
}

class Cat extends Animal {
	constructor() {
		super();
		this.name = '猫';
		this.eat = function () {
			console.log('吃鱼');
		}
	}
}

let cat = new Cat();
let cat2 = new Cat();

console.log(cat.name); // 猫
console.log(cat.type); // ['cat', 'dog']
cat.type.push('mouse');
console.log(cat.type); // ['cat', 'dog', 'mouse']
console.log(cat2.type); // ['cat', 'dog']
cat.eat(); // 吃鱼
```

- new 关键字原理

```js
function myNew(Fn, ...args) {
	// 1.创建一个空对象
	let obj = {};
	// 2.将 Fn 的原型赋值给 obj
	obj.__proto__ = Fn.prototype;
	// 3.为 obj 绑定 this
	let res = Fn.apply(obj, args);
	// 4.如果该函数没有返回对象，则返回 obj
	return res instanceof Object ? res : obj;
}

function Animal(name, age) {
	this.name = name;
	this.age = age;
}

let res = myNew(Animal, '小猫', 2);
console.log(res);
```

- number 类型表示整数的最大范围

```js
Number.MAX_VALUE = 1.7976931348623157e+308; // 1.7976931348623157∗10^308
Number.MIN_VALUE = 5e-324; //  5*10^-324
```

- 原生 JS 对 DOM 操作的方法

```text
1.获取 DOM 元素
    document.getElementById
    document.getElementsByTargetName
    document.getElementsByClassName
    document.querySelector
    document.querySelectorAll
    document.body
    document.documentElement
2.操作 DOM 元素
    dom.appendChild
    dom.removeChild
    dom.replaceChild
    dom.insertBefore
    dom.createElement
    dom.createAttribute
    dom.createTextNode
    dom.getAttribute
    dom.setAttribute
    dom.innerHTML
    dom.innerText
```

- js 异步处理发展史

```text
1、最开始使用回调函数，具有回调地狱的问题
2、为解决回调地狱的问题，后面引入 Promise
3、后面又引入了 Generator 迭代器
4、为是代码异步代码更加趋近同步代码，不用像 Promise 那样频繁的使用 then，最后引入了 async await
```

- typeof、 instanceof 区别

```text
1、typeof：用来判断普通数据类型，如果用来判断 null，结果为 object，如果是函数，结果是 function
2、instanceof：用来判断引用数据类型，原理是判断目标对象的原型上是否存在指定数据类型，存在返回 true，
    不存在返回 false，Object 是所有引用数据类型的原型
```

- ["1","2","3"].map(parseInt) 结果，并解释原因

```js
['1', '2', '3'].map((item, index) => {
	// parseInt 接受两个参数，第一个参数是给出的原始字符串，第二个参数是范围 2-36 的数字，表示原始字符串的进制，0默认为10进制
	// '1': parseInt('1', 0) => parseInt('1', 10) => 1
	// '2': parseInt('2', 1) => 由于第二个参数小于 1 所以返回 NaN
	// '3': parseInt('3', 2) => 由于原始字符串不符合第二个参数所指定的进制格式，返回NaN
	return parseInt(item, index);
})
```

- 不可以用箭头函数场景

```js
// 1.定义对象方法的时候
const obj = {
	str: '111',
	fn: () => {
		console.log(this === window)  // true
	}
}

// 2.定义原型方法的时候
function Cat(name) {
	this.name = name
}

Cat.prototype.sayCatName = () => {
	console.log(this === window)  // true
	return this.name
};

const cat = new Cat('Mew')
cat.sayCatName()  // undefined
// 3.定义事件回调函数的时候
const button = document.getElementById('btn');
button.addEventListener('click', () => {
	console.log(this === window); // true
	this.innerHTML = 'button'
});
// 4.定义构造函数的时候
const Message = (text) => {
	this.text = text;
}
const msg = new Message('message add') //Uncaught TypeError: Message is not a constructor
// 5.需要使用 arguments 参数的时候
let func = (a, b) => {
	console.log(argements); // Uncaught ReferenceError: argements is not defined
}

// 使用 function 来解决
function func1(a, b) {
	console.log(argements); // Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}
```

- 怎么判断 this 指向？

```text
1.函数作为对象的属性调用 => 谁调用就是谁
2.直接调用函数 => 全局是谁就是谁
3.call、apply、bind 的函数调用场景 => 绑定谁就是谁
4.函数的构造调用 => 新创建的对象
5.箭头函数 => 继承箭头函数所在上下文的 this
6.箭头函数 => 箭头函数 this 指向函数创建时所在的上下文
```

- addEventListener 的第三个参数

```text
1、useCapture：指定事件处理函数的时期或阶段如果时 true 表示在时间捕获阶段执行，false 表示在事件冒泡阶段执行
2、options：一个指定有关 listener 属性的可选参数对象
    (1) capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。
    (2) once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。
    (3) passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看 使用 passive 改善的滚屏性能 了解更多.
    (4) signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。
```

- 基本数据类型里面的 symbol 的应用场景

```js
// 1.消除魔法字符
if (type === 'basic') {
	return <div>basic tab</div>
}

if (type === 'super') {
	return <div>super tab</div>
}
// =>
const tabTypes = {
	basic: Symbol(),
	super: Symbol(),
}

if (type === tabTypes.basic) {
	return <div>basic tab</div>
}

if (type === tabTypes.super) {
	return <div>super tab</div>
}

// 2.作为对象属性 当一个复杂对象中含有多个属性的时候，很容易将某个属性名覆盖掉，利用 Symbol 值作为属性名可以很好的避免这一现象。
const name = Symbol('name');
const obj = {
	[name]: 'ClickPaas',
}

// 3.模拟类的私有方法
const speak = Symbol();

class Person {
	[speak]() {}
}
```

- commonjs 和 module 的区别

```text
1、import 和 import()
	(1) import: 代码在编译阶段直接执行静态加载，加载顺序优于其他 js 代码，导致无法将其放在 if 中进行条件引入
	(2) import():
		① 可实现动态加载，引入地址可以动态改变
		② 返回 promise 对象
		③ 代码在 js 运行阶段执行

2、exports 和 module.exports
	(1) module.exports 初始值为一个空对象 {}
    (2) exports 是指向的 module.exports 的引用
    (3) require() 返回的是 module.exports 而不是 exports
    (4) module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports 即可
```

- object.create 的作用

```js
// 指定以某个对象为原型，创建新的对象
// 原理
function myCreate(target) {
	let obj = {};
	obj.__proto__ = target;
	return obj;
}

function Animal() {
	this.name = 'animal';
}

let animal = new Animal();
let obj = myCreate(animal);
console.dir(obj);
// Object.create()方法还可以接受第二个参数，用来给新创建的对象添加可枚举属性，与Object.defineProperies方法第二个参数用法一样
```

- try catch 和 throw new error 的区别

```text
1、try catch 可以检测通过 try 代码块中的代码是否有抛出错误，如果有抛出错误，就会执行 catch 代码块中的语句，并不会中断代码的执行
2、throw new error 会抛出一个异常，会在这个抛出异常的地方中止代码的运行，可以通过 try catch 配合使用来提高代码的健壮性
```

- undefined 和 null 的区别？

```text
1、undefined：
	(1) 通过 let、var 或者是直接申明的变量如果没有赋初值，那么这个变量就会是 undefined
    (2) 通过访问一个对象中不存在的属性，也会是 undefined
    (3) 通过访问一个函数的形参，如果调用函数时没有传入这个形参，那么这个形参也将是 undefined
    (4) 使用 void 对表达式求值时，返回的值都是 undefined
2、null：null 字面量是空值，表示一个对象被人为的赋值为空对象，内存中表示栈中的变量没有指向堆内存中的地址，当一个对象被赋值为空的时候，其之前所指向的堆内存中的对象将会被垃圾回收。
3、undefined 和 null 都是 js 的基本数据类型
	(1) undefined 可以通过 type of 来进行类型判断
	(2) null 可以通过Object.prototype.toString.call(null) 来进行类型判断
    (3) 他们都表示一个无效的值，在 if 判断中，都会被解释称 false
```

- 堆、栈区别

```text
1、堆：是堆内存的简称，是动态分配内存的，内存大小不固定，也不会自动释放内存，用来存储引用数据类型的值
2、栈：先进后出，内存占用大小固定，线性存储，容量小，并由系统自动分配与释放。用来存储基本数据类型的值，引用数据类型只会在栈中存放一个其在堆内存中的一个地址，用来找到堆内存中的引用数据类型
```

- 堆、栈垃圾回收机制

```text
1、堆：堆内存中的对象不会随着方法的结束而销毁，因为这个对象可能被其他地方引用。只有当一个对象没有任何变量引用时才会被垃圾回收
2、栈：在栈中的变量被使用完就被垃圾回收
```

- 闭包为什么不能被其他直接访问

```text
1、因为具有函数作用域，函数内部可以访问外层函数的作用域，但是外层函数不能访问内层函数的作用域
2、通过闭包可以实现函数内部的变量与函数外部的变量进行分离，通过闭包来返回所需要的数据，防止污染全局变量
```

- 原型链终点

```text
null
```

- es6 class 怎么设置原型、静态、实例方法

```text
1、es6 设置原型：通过使用寄生组合模式继承原型
2、静态属性：在类中的方法名或者属性名前加上 static 实现静态属性或方法
3、实例方法：在 class 类中直接添加方法，在类实例化后通过 实例.方法名调用
```

- cookie、localStorage、sessionStorage 的区别，哪些情况和设置，请求不会携带 cookie

```text
1、cookie：
	(1) 在 HTML4 中被用来给客户端保存数据，每次请求时都会在 HTTP 请求头中携带 cookie
    (2) cookie 如果不设置过期时间，默认在会话结束后消失，如果设置了过期时间，那么会被存储在本地硬盘中，等到过期时间一到便会自动消失
    (3) cookie 的存储大小很小，只有 4kb
2、localStorage：
	(1) localStorage 是 HTML5 推出的，用来解决客户端数据存储问题
    (2) localStorage 存储空间为 5MB，数据是永久存储的，不会因为浏览器关闭或是标签关闭而造成数据的丢失，除非主动删除，不然数据是不会消失的
    (3) localStorage 的数据不会被发送到服务端，更具有安全性和更佳的性能
3、sessionStorage：
	(1) sessionStorage 同样是 HTML5 推出用来解决客户端数据存储问题的
    (2) sessionStorage 存储空间为 5MB，数据仅在当前会话中有效，如果浏览器标签或者页面关闭，则会删除在 sessionStorage 中的数据
    (3) sessionStorage 的数据也不会被发送到服务端，更具有安全性和更佳的性能
4、cookie：
	(1) 请求不会携带：domain 跟 path 属性与请求域名路径不匹配
    (2) 如果有 secure 属性，在非 https 的请求协议中不会携带 cookie
    (3) 跨域的 ajax 请求不会携带 cookie，如果需要携带，则需要配置 withCredentials 请求头以及 CORS 响应头
    (4) 如果请求跨站，需要判断 SameSite 属性是否满足发送条件
```

- 说说 fetch，优缺点？怎么做 polyfill

```text
1、优点：
	(1) 基于 Promise 设计，返回 Promise 对象，解决回调地狱问题
    (2) api 简洁，易用
2、缺点：
	(1) API 偏底层，需要进行二次封装，只会对网络请求报错，如 400、500 都会被当成成功的请求
    (2) 不会携带 cookie，需要手动配置
    (3) 不支持 abort，不能阻止在请求过程中中断请求，造成性能浪费
    (4) 不能检测请求进度
    (5) 浏览器兼容性差，需要 polyfill 处理
3、polyfill：使用 isomorphic-fetch 和 whatwg-fetch 进行处理
```

- fetch 并行请求与取消请求如何处理？

```js
// 取消请求 AbrotController
// AbortController 会监听 signal 上的 abort 事件。
// 当一个 fetch 被中止，它的 promise 就会以一个 error AbortError reject，因此我们应该对其进行处理，例如在 try..catch 中。
// 中止 fetch，调用 controller.abort() 即可：
// 1 秒后中止
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);
try {
	let response = await fetch('/article/fetch-abort/demo/hang', {
		signal: controller.signal
	});
} catch (err) {
	if (err.name == 'AbortError') { // handle abort()
		alert("Aborted!");
	} else {
		throw err;
	}
}

```

- event loop 原理，宏任务微任务，你知道有哪些回调？

```text
1、EventLoop：
	(1) 是一种计算机运行机制，可以解决 JavaScript 单线程带来的一些问题。
    (2) 执行一个宏任务，过程中遇到微任务时，将其放到微任务的事件队列里，当前宏任务执行完成后，会查看微任务的事件队列，依次执行里面的微任务。如果(3) 还有宏任务的话，再重新开启宏任务
2、微任务:
	(1) 微任务包括： Promise，Object.observe(已废弃)，MutationObserver(html5新特性)，process.nextTick。
    (2) 其中 process.nextTick 只存在于 Node 中，MutationObserver 只存在于浏览器中。
3、宏任务：
	(1) script(整体代码)，I/O， setTimeout，setInterval，requestAnimationFrame，setImmediate。
    (2) 其中 setImmediate 只存在于 Node 中，requestAnimationFrame 只存在于浏览器中。
```

- 浏览器事件机制，为什么要有微任务？宏任务不行吗

```text
1、为了将异步队列任务划分优先级，一个 Event Loop，Microtask 是在 Macrotask 之后调用，
Microtask 会在下一个 Event Loop 之前执行调用完，并且其中会将 Microtask
执行当中新注册的 Microtask 一并调用执行完，然后才开始下一次 Event Loop，
所以如果有新的 Macrotask 就需要一直等待，等到上一个 Event Loop 当中 Microtask 被清空为止。
由此可见，我们可以在下一次 Event Loop 之前进行插队。
2、如果不区分 Microtask 和 Macrotask，那就无法在下一次 Event Loop 之前进行插队，
其中新注册的任务得等到下一个 Macrotask 完成之后才能进行，这中间可能你需要的状态就无法在下一个
Macrotask 中得到同步。
```

- requestAnimationFrame setTimeout setInterval 区别

```text
1、setTimeout: 回调函数会放入宏任务队列中, 会在主线程中所有同步代、微任务以及在 setTimeout 之前的所有任务都完成后才会进行任务回调执行时间不够精确, 回调函数会按照给定时间间隔定时执行一次
2、setInterval: 同上, 只是回调函数会按照给定时间间隔定时执行
3、requestAnimationFrame: 类似 setTimeout, 不过浏览器会重新开一个线程, 把每一帧中所有的 DOM 操作集中起来, 根据浏览器的刷新时间间隔的回调流中完成绘制
```

- dom 事件流

```text
1、dom 事件流一共有两种, 事件冒泡流和事件捕获流
    (1) 事件冒泡流: 事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播, 直到传播至 document
    (2) 事件捕获流: 事件从 document 向具体 dom 元素开始传播
2、通过指定 addEventListener 中的第三个参数:
    (1) 布尔值为 true，表示在事件捕获阶段执行事件处理程序
    (2) 布尔值为 false，表示在事件冒泡阶段执行事件处理程序
    (3) 如果不写布尔值，默认为 false
```

- 事件冒泡？

```text
当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。
```

- 线程与进程的关系？JS 为什么是单线程的？

```text
1、进程是 CPU 分配资源的最小单位
2、线程是 CPU 调度的最小单位
3、一个进程可以拥有多个线程
4、js 是一门客户端脚本语言, 主要任务就是为了处理用户的交互, 而用户的交互无非就是响应 DOM 的增删改,使用事件队列形式, 一次事件循环只处理一个事件响应, 使得脚本能够相对连续的执行. 如果 js 被设计成多线程的语言, 那么 DOM 之间必然会存在资源的竞争, 使得语言变得非常的臃肿, 性能与资源的消耗将会加大, 所以 js 被设计成一门单线程的语言
```

- axios 发送 get 和 post 请求有什么区别

```text
1、get: 请求参数是 params, 发送请求时将参数拼接到 url 后边
2、post: 请求参数时 data, 发送请求时将参数放在请求体中
```

- JSON 字符串转换成 JSON 对象

```js
let jsonStr = '[1, 2, 3, 4, "json 字符串"]';
let res = JSON.parse(jsonStr);
console.log(res);
```

- 前端分片的 api 叫什么

```js
File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice
```

- 柯里化

```text
① 在全局环境中调用就指向window。
② 作为对象的方法调用就指向该对象。
③ 作为构造函数调用就指向这个新创建的对象。
④ 可以使用apply,call,bind改变this指向。
⑤ 箭头函数中的this与定义时所处的上下文绑定，且不能被改变， 箭头函数this指向取决于它外层找到的离它最近的第一个非箭头函数的this。
```

```text
① 线程是包含在进程中的，线程其实就是一个指令序列，如果加上计算机分配给它的资源（如内存等）之后它就是一个进程。
② 可以设想一个场景：JS是多线程的，如果几个线程同时对一个DOM节点进行操作，浏览器该怎么处理呢？为了避免这种冲突JS设计为单线程。
```

- 鼠标点击了 a 标签，然后又弹起这么一个过程，这个过程到底触发了哪些事件？

```text
只触发了 click 事件
```

- eval 用过吗？你说不推荐用，那什么时候必须用 eval

```text
1、不易调试，无法在浏览器中打断点进行调式
2、性能低，由于 eval 中的代码不可预测，所以浏览器会花费大量时间去编译它
3、安全性低，容易造成 xss 攻击
```

- Generator 和 async、await 的区别

```text
1、使用方式不同：
    ① async / await 使用 await 而不是 yield
    ② await 仅适用于 Promise
    ③ async / await 使用 async function 关键字，generator 使用 function*
2、async / await 是基于 generator 实现的，是 generator 的一个语法糖
```

- 什么是函数柯里化？目的？

```text
1、柯里化是：把接收多参的函数转化成可以逐个调用单个参数并返回接收剩下参数的函数
2、目的：
    ① 参数复用：函数柯里化使用闭包保存了一部分的参数，在后续调用时无需要传递已经传过的参数，避免重复传参
    ② 提前确认：对于一些需要提前进行以此判断的场景如判断浏览器是否兼容某个 api，使用函数柯里化先进行一次判断，返回新函数，避免后续再次判断造成性能浪费
    ③ 延迟执行：函数并不是立即调用，只有等参数数量达到指定数量时才调用函数
    ④ 使用灵活：柯里化可以生成粒度更小的函数，可以使用这些粒度小的函数组合成功能更强大的函数
3、缺点：
    ① 函数柯里化涉及大量递归以及闭包，造成性能的浪费
```

- 0.1+0.2 为什么！=0.3，如何解决

```text
1、原因：由于计算机在进行计算时会将十进制转换为二进制，而在进行小数运算时，js 会将小数转换为二进制数，0.1 被转换为 0.0001100110011..., 0.2 被转换为 0.00110011001100..., 相加结果为无限循环小数而计算机不允许出现无限循环小数，所以会丢弃后边多余的数，造成精度缺失，所以 0.1 + 0.2 != 0.3
2、解决方式：将 0.1 和 0.2 扩大十倍变成整数，计算出结果后再缩小 1/10
```

- 实现效果

```js
const repeatFunc = repeat(console.log, 4, 3000);
repeatFunc("helloworld");

// 每 3 秒打印一个 helloworld，总计执行 4 次
async function repeat(fn, count, timeout) {
	for (let i = 0; i < count; i++) {
		await sleep(timeout);
		fn.call();
	}
}

function sleep(time) {
	return new Promise(resolve => setTimeout(() => resolve(), time));
}

repeat(function () {
	console.log('helloworld');
}, 4, 3000);

```

- 实现效果

```js
const array = [1.1, 1.2, 2.3, 2.2, 3.1]

// test: groupBy(array, Math.floor) => { 1: [1.1, 1.2], 2: [2.3, 2.2], 3: [3.1] }
function groupBy(array, fn) {
	let resObj = {};
	array.forEach((item, index) => {
		let tempNum = fn(item);
		if (!resObj[tempNum]) {
			resObj[tempNum] = [];
		}
		resObj[tempNum].push(item);
	});
	return resObj;
}

console.log(groupBy(array, Math.floor));
```

- 写个转换函数，把一个 JSON 对象的 key 从下划线形式（Pascal）转换到小驼峰形式（Camel）

```js
/**
 * 说明：
 *
 * 示例：
 *   converter({"a_bc_def": 1}); // 返回 {"aBcDef": 1}
 */

let jsonStr = {
		a_bc_d: 1,
		asd_asd_asd: 2,
		a_a_b: [1, 'asd', [{a_basd_asd: 1}]]
	};

function converter(obj) {
	/* 功能实现 */
	if (!(obj instanceof Object)) {
		return obj;
	}
	if (obj instanceof Array) {
		let tempArr = [];
		for (let item of obj) {
			tempArr.push(converter(item));
		}
		return tempArr;
	}
	let tempObj = {};
	for (let key in obj) {
		if (obj.hasOwnProperty(key)) {
			let newKey = change(key);
			tempObj[newKey] = converter(obj[key]);
		}
	}
	return tempObj;

	function change(key) {
		let tempArr = key.split('_');
		if (tempArr.length < 2) {
			return key;
		}
		for (let i = 1; i < tempArr.length; i++) {
			tempArr[i] = String.fromCharCode(tempArr[i][0].charCodeAt() - 32) + tempArr[i].substring(1);
		}
		return tempArr.join('');
	}
}

console.log(converter(jsonStr));
```

- 实现效果

```js
// 一个请求超出十秒抛出异常，允许出错三次怎么实现
async function myFetch(req) {
	let count = 3;
	let timer = null;
	timer = setInterval(() => {
		console.log(`第${3 - count + 1}次超时`);
		if (--count <= 0) {
			clearInterval(timer);
			throw new Error('超时');
		}
	}, 2000);
	let res = await req.call(this, 5999);
	if (count > 0) {
		console.log(res);
	}
	clearInterval(timer);
}

function sleep(time) {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('成功');
		}, time);
	});
}

myFetch(sleep);
```

- 实现效果

```js
// 实现一个函数add函数 我这样调用它add(1,2,3)(4)(5,6)() 输出21
function curry(fn) {
	return function curried(...args) {
		if (fn.length <= args.length) {
			return function () {
				return fn.apply(this, args)
			};
		}
		return function (...args2) {
			return curried.apply(this, [...args, ...args2]);
		}
	}
}

function getSum(one, two, three, fore, five, six) {
	return one + two + three + fore + five + six;
}

let add = curry(getSum);
console.log(add(1, 2, 3)(4)(5, 6)());
```

- 代码实现

```js
function toBase(m, n) {
	let resArr = [];
	let mod = m;
	do {
		mod = Math.floor(m / n);
		resArr.unshift(m % n);
		m = mod;
	} while (mod !== 0);
	return resArr.join('');
}

console.log(toBase(100, 2)); // 1100100
console.log(toBase(10, 3)); // 101
// m是一个10进制的数
// n是一个2-9的整数
```

- 看代码输出

```js
console.log('a');

setTimeout(function () {
	console.log('b');
	process.nextTick(function () {
		console.log('c');
	})
	new Promise(function (resolve) {
		console.log('d');
		resolve();
	}).then(function () {
		console.log('e')
	})
})
process.nextTick(function () {
	console.log('f');
})
new Promise(function (resolve) {
	console.log('g');
	resolve();
}).then(function () {
	console.log('h')
})

setTimeout(function () {
	console.log('i');
	process.nextTick(function () {
		console.log('j');
	})
	new Promise(function (resolve) {
		console.log('k');
		resolve();
	}).then(function () {
		console.log('l')
	})
})
// a、g、f、h、b、d、c、e、i、k、j、l
```

- 看代码输出

```js
var o = {
	a: 10,
	b: {
		a: 12,
		fn: function () {
			console.log(this.a);
			console.log(this);
		}
	}
}
o.b.fn();
var j = o.b.fn;
j();

function something(x) {
	this.x = x
}

something(3);
console.log(x);
//  12 b{} undefined window 3
```

- 输出结果

```js
function foo() {
	console.log(this.name);
}

function Foo(fn) {
	fn();
}

var obj = {
	name: 'zl', foo,
}
var name = "Heternally";
Foo(obj.foo);

// Heternally
```

- 看代码说结果

```js
// 看代码说结果
setTimeout(function () {
	console.log('setTimeout1');
	new Promise(function (resolve) {
		console.log('promise0');
		resolve()
	}).then(function () {
		console.log('settimeout promise resolveed');
	})
});
setTimeout(function () {
	console.log('setTimeout2');
});
const P = new Promise(function (resolve) {
	console.log('promise');
	for (var i = 0; i < 10000; i++) {
		if (i === 10) {
			console.log('for');
		}
		if (i === 9999) {
			resolve('resolve');
		}
	}
}).then(function (val) {
	console.log('resolve1');
}).then(function (val) {
	console.log('resolve2');
});
new Promise(function (resolve) {
	console.log('promise2');
	resolve('resolve');
}).then(function (val) {
	console.log('resolve3');
})
console.log('console');

/*
    promise 中的 then 按照当前微任务队列中的顺序执行，如果两个 promise，第一个 promise 有两个 then，
    另外一个有一个 then，先执行第一个 promise 中的第一个 then，再执行第二个 promise 中的第一个 then，
    最后执行第一个 promise 中的 then，以此类推交替执行
  promise
  for
  promise2
  console
  resolve1
  resolve3
  resolve2
  setTimeout1
  promise0
  settimeout promise resolved
  settimeout2
 */
```

- 代码输出

```js
var a = [1, 2, 3, 4];

function set(a) {
	a = [5, 6, 7, 8];
}

set(a);
console.log(a); // [1, 2, 3, 4]
a = [5, 6, 7, 8];
console.log(a) // [5, 6, 7, 8]
// 追加，实现打印 a = [5,6,7,8]
```

- 看代码说输出

```js
var count = 10;

function a() {
	return count + 10;
}

function b() {
	var count = 20;
	return a();
}

console.log(b()); // 20
```

- 看代码说输出

```js
Function.prototype.a = () => console.log(1);
Object.prototype.b = () => console.log(2);

function A() {};
var a = new A();

a.a(); // 报错
a.b(); // 2
```

- 看代码说输出

```js
function Foo() {
	this.a = 1;
	return {
		a: 4,
		b: 5,
	};
}

Foo.prototype.a = 6;
Foo.prototype.b = 7;
Foo.prototype.c = 8;

var o = new Foo();

console.log(o.a); // 4
console.log(o.b); // 5
console.log(o.c); // undefined
```

- 看代码输出

```js
function T1() {
	this.name = 't1';
	this.age = 19;
}

function T2() {
	this.name = 't2';
	this.age = 19;
	return 19;
}

function T3() {
	this.name = 't3';
	this.age = 19;
	return {
		name: 't',
		age: 20
	};
}

function T4() {
	this.name = 't4';
	this.age = 19;
}

console.log(new T1()); // T1 {name: 't1', age: 19}
console.log(new T2()); // T2 {name: 't2', age: 19}
console.log(new T3()); // {name: 't', age: 20}
T4.prototype = new T1();
T4.prototype.type = 'expert';
const t4 = new T4();
console.log(t4); // T4 {name: 't4', age: 19}
console.log(t4.type); // expert
console.log(t4 instanceof T1); // true
console.log(t4 instanceof T2); // false
console.log(t4 instanceof T4); // true
```

- 看代码输出

```js
console.log('a');
setTimeout(() => {
	console.log('b');
}, 0);
console.log('c');
new Promise((resolve) => {
	console.log('d');
	resolve(2);
}).then(() => {
	console.log('e');
	setTimeout(() => {
		console.log('f')
	}, 100)
});
console.log('g');
// a c d g e b f
```

- 看代码输出

```js
var name = 'name';
var A = {
	name: 'A',
	sayHello: function () {
		let s = () => console.log(this.name);
		return s;
	}
};
let sayHello = A.sayHello();
sayHello();
var B = {
	name: 'B'
};
sayHello.call(B);
// A A
```

- 看代码说结果

```js
var name = 1;
(function () {
	console.log(name + this.name); // browser: -> 'undefined1'; Node.js: -> NaN
	var name = '2';
	console.log(name + this.name); // browser: -> '21'; Node.js: -> '2undefined'
})();
```

- 看代码写输出，并讲思路

```js
const obj = {
	a: 1,
	b: {
		c: 2
	}
};
const {
	a,
	b: {c}, // 这个为了取出 c
	b // 这个为了取出 b
} = obj;
console.log(a, b, c);
// 1, {c: 2}, 2
```

- 匿名函数的打印结果

```js
var a = 1;
(function a() {
	a = 2;
	console.log(a)
})()
// function a
```

- 异步执行顺序

```js
async function async1() {
	console.log("async1")
	await async2() // await 后边如果跟随异步任务，则被放入宏任务队列，如果时同步任务，则直接执行
	console.log("async1 end")
}

console.log("scripts start")
async1()

async function async2() {
	await console.log("async2")
}

new Promise((resolve, reject) => {
	console.log("promise1")
	resolve()
}).then(() => {
	console.log("promise2")
})
setTimeout(() => {
	console.log("setTimeout")
})
console.log("scripts end")
/*
scripts start
async1
async2
promise1
scripts end
promise2
async1 end
setTimeout
 */
```

- 看代码输出

```js
var a = 1

function foo() {
	var a = 2

	function inner() {
		console.log(this.a)
	}

	inner()
}

foo() // 1
```

- 看代码输出

```js
const a = 10;
const obj = {
	a: 13,
	b: () => {
		console.log(this.a);
	},
	c: function () {
		console.log(this.a)
	},
	d: function () {
		return () => {
			console.log(this);
		}
	},
	e: function () {
		return this.b
	}
}
obj.b() // undefined
obj.c() // 13
obj.d()() // obj
obj.e()() // undefined
```

- 看代码输出

```js
function Foo() {
	Foo.a = function () {
		console.log(1);
	}
	this.a = function () {
		console.log(2);
	}
}

Foo.prototype.a = function () {
	console.log(3);
}
Foo.a = function () {
	console.log(4);
}
Foo.a(); // 4
let obj = new Foo();
obj.a(); // 2
Foo.a(); // 1
```

- 代码输出

```js
const foo = new Promise(resolve => {
	console.log(1);
	resolve();
	console.log(2);
})

foo.then(() => {
	console.log(3);
})

console.log(4);
// 1 2 4 3
```

- 代码输出

```js
var name = 'window';

var A = {
	name: 'A',
	sayHello: () => {
		console.log(this.name)
	}
}

A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window
```
