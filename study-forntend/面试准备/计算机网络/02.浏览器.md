- 跨域解决方案

```text
1、CORS（跨域资源共享），它使用额外的 HTTP 头俩告诉浏览器，让运行在一个 origin 上的 Web 应用被准许访问来自不同源服务器上的指定资源。当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源是，资源发起一个跨域 HTTP 请求（在 CORS 中会有简单请求和复杂请求的概念）
	(1) 简单请求：
		1) 除以下的请求方法，其他的都是复杂请求
			① GET
			② HEAD
			③ POST
		2) 认为设置以下集合外的请求头：
			① Accept
			② Accept-Language
			③ Content-Language
			④ Last-Event-ID
			⑤ COntent-Type（只限于三个值）：application/x-www-form-urlencoded、multipart/form-data、text/plain
	(2) 除以上情况都是
2、服务器正向代理：利用服务器与服务器之间通讯不会受到跨域的影响，如 Vue-cli 中的 proxy、node 代理
3、Nginx 反向代理
4、JSONP：利用 script 标签没有跨域限制的特性进行跨域访问
5、使用 Websocket
```

- xss、csrf 攻击原理和防范

```text
1、XSS：跨站脚本攻击。
	(1) 原理：通常指的是通过利用网页开法时留下的漏洞，通过注入恶意指定代码到网页，使用户加载并执行攻击者恶意制造的网页程序
	(2) 防范：
		① 前后端做好前端输入检测，过滤、编码掉用户的非法输入
2、CSRF：跨站请求伪造。
	(1) 原理：攻击者有道受害者进入到第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取到的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的
	(2) 防范：
		① 阻止不明外域的访问
		② 提交时要求携带上本域
```

- 性能优化怎么做的 (webpack 构建压缩，编码优化， 请求优化，缓存）

```text
1、Webpack：
	(1) 使用 include、exclude 避免不必要的转译
	(2) 防止多次重复打包第三方包，导致打包体积过大（使用 Webpack 插件：DllPlugin）
	(3) 对构建出的代码进行体积压缩，如删除冗余代码（Tree-shaking）
	(4) 按需加载
	(5) 小图片使用 base64 编码，减少请求次数
2、编码优化：
	(1) CSS ：
		① 使用 transform 代替 width、height 等属性
		② 减少 CSS 选择器的嵌套层数
	(2) JS
		① 少使用会造成重排与重绘的属性和操作
		② 按需加载
		③ JS 写在 </body> 之上
3、网络：
	(1) 减少请求次数：
		① 使用 HTTP1.1 的长连接
		② 多个请求合并成一个请求
	(2) 减少单个请求资源大小：
		① 使用 HTTP2.0 的首部压缩
		② 对请求进行压缩，如 Gzip：Accept-Encoding: gzip
	(3) 图片优化：
		① 在质量与性能之间选取平衡点，对图片大小进行控制，使用 jpg、webp、svg、base64
	(4) 使用 CDN
	(5) 服务端渲染
4、缓存：
	(1) 利用浏览器缓存，减少 HTTP 请求次数
		① 强缓存
		② 协商缓存
```

- 首屏怎么优化

```text
1、减少入口文件体积
2、静态资源本地缓存
3、UI 框架按需加载
4、图片资源压缩
5、防止组件重复打包
6、开启 Gzip 压缩
7、使用 CDN
8、使用服务端渲染
```

- 浏览器缓存

```text
1、原理：浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中的 HTTP 头的缓存字段决定是否缓存结果，是的话就将请求结果和缓存标识存入浏览器缓存中
2、强制缓存：强制缓存就是向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定时候使用该缓存结果的过程
	(1) 强制缓存有三种：
		① 不存在缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求
		② 存在该缓存和缓存标识，但该结果已经失效，强制缓存失效，则使用协商缓存
		③ 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
	(2) 强制缓存规则：浏览器向故武器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高
		1) Expires 是 HTTP1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即在此发起请求时，如果哭护短的时间小于 Expires 的值时，直接使用缓存结果。到了 HTTP1.1，Expires 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理时使用哭护短的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因发生误差，那么强制缓存则会直接失效
		2) Cache-Control 是 HTTP1.1 中的控制缓存字段，只要用于控制网页缓存，只要值为：
			① publi：所有内容都会被缓存（客户端和代理服务器都可以被缓存）
			② private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
			③ no-cahce：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
			④ no-store：所有内容都不会被缓存，即不适用强制缓存，也不使用协商缓存
			⑤ max-age=xxx（xxx 是数字）：缓存内容将在 xxx 秒后失效
3、协商缓存：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存，
	(1) 协商缓存有两种情况：
		1) 协商缓存生效，返回 304：
			① 浏览器发起 HTTP 请求，先查找浏览器缓存
			② 该请求强制缓存结果失效，则只返回缓存标识
			③ 浏览器携带该资源的缓存标识，发起 HTTP 请求
			④ 304，标识该资源无更新
			⑤ 浏览器向浏览器缓存获取请求的缓存结果
			⑥ 返回请求的缓存结果
		2) 协商缓存失效，返回 200 和请求结果
			① 浏览器向浏览器缓存发起 HTTP 请求
			② 该缓存结果失效，则只返回缓存标识
			③ 流量携带这些缓存标识，发起 HTTP 请求
			④ 该资源更新了，重新返回结果 和 200
			⑤ 将该请求结果和缓存标识存入浏览器缓存中
	(2) 控制协商缓存的字段分别有：Etag/If-None-Match/Last-Modified/If-Modified-Since，其中 Etag/If-None-Match 的优先级比 Last-Modified/If-Modified-Since 高，同时存在则是由 Etag/If-None-Match 生效
		1) Etag/If-None-Match
			① Etag：服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）
			② If-None-Match：客户端再次发起请求时携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源所在服务器的 Etag 值做对比，一致则返回 304，标识资源无更新，继续使用缓存文件，不一致则重新返回资源文件，状态码 200
		2) Last-Modified/If-Modified-Since（只能精确到秒级，误差大）
			① Last-modified 是服务器响应请求时，返回该资源文件在资源服务器最后被修改的时间
			② If-Modified-Since 是客户端在此发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间，服务器收到该请求，发现请求头含有 If-Modified0Since 字段，则会根据 If-Modified-Since 字段值与该资源在服务器最后被修改的时间最多比，若服务器的资源最后修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码 200，反则返回 304，代表资源无更新，可以继续使用缓存文件
```

- 前端的一次请求会经过哪些缓存

```text
1、浏览器缓存
2、DNS 缓存
3、服务器缓存
```

- 浏览器内核

```text
1、Gecko: 早期被 Netscape 和 Firefox 浏览器使用
2、Trident：微软开发，被 IE4 ~ IE11 浏览器使用
3、Webkit：苹果基于 KHTML 开发、开源的，用于 Safari 和 Google Chrome 之前也在使用
4、Blink：是 Webkit 的一个分支，Google 开发，目前用于 Google Chrome，Edge，Opera
```

- 什么不受跨域影响

```text
1、由于跨域是浏览器保障安全的一种同源策略，如果不在浏览器中使用 ajax 请求，那么就不会受到跨域的影响，如 postman 和 node 等
2、在 HTML 标签里，script、img、a 标签等没有跨域的问题
3、满足 CORS 标准的请求不受跨域影响
4、通过代理避免跨域的影响
```
