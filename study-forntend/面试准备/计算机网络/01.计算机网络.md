- OSI 七层网络模型，每一层有什么作用

```text
1、网络层：
	(1) 功能：
		① 应用层为操作系统或网络应用程序提供访问网络服务的接口，意在方便应用从网络中接收数据
	(2) 协议：
		① HTTP：超文本传输协议
		② FTP：文件传输协议
		③ SMTP：简单邮件传输协议
		④ TELNET：TCP/IP 终端仿真协议
		⑤ POP3：邮局协议第三版
		⑥ IMAP：因特网信息访问协议
		⑦ DNS：域名系统
2、表示层：
	(1) 功能：
		① 提供数据的压缩、解压、加密、解密等格式化表示和转换数据服务的功能，意在解决不同操作系统之间的讯通语法问题
	(2) 协议：
		① LPP：轻量级表示协议
		② NBSSN：NetBios 会话服务协议
		③ XDP：外部数据表示协议
3、会话层：
	(1) 功能：
		① 负责建立和断开通信连接
	(2) 特点：
		① 数据单元：报文
4、传输层：
	(1) 功能：
		① 为上层提供端到端的、透明的、可靠的数据传输服务
	(2) 特点：
		① 数据单元：数据包，TCP 中叫段，UDP 中叫数据报
	(3) 协议：
		① TCP：传输控制协议（面向连接、可靠）
		② UDP：用户数据报协议（面向无连接、不可靠）
5、网络层：
	(1) 功能：
		① 为数据包选择合适的路由和交换结点，确保数据及时传递
	(2) 特点：
		① 数据单元：数据包
	(3) 协议：
		① IP：互联网协议
		② ICMP：互联网控制信息协议
		③ IGMP：互联网组管理协议
6、数据链路层：
	(1) 功能：
		① 在物理层提供比特流服务的基础上建立相邻节点间的数据链路，通过差错控制提供数据帧在信道上的无差错传输
	(2) 特点：
		① 数据单元：帧
	(3) 协议：
		① PPP：点对点协议
		② HDLC：高级数据链路控制
		③ STP：生成树协议
7、物理层：
	(1) 功能：
		① 解决两台物理机之间的通讯需求问题，用以建立、维护和拆除物理链路连接
	(2) 特点：
		① 数据单元：比特
	(3) 协议：
		① IEEE 802.2
		② Ethernet v.2
```

- 计算机网络分为哪五层？tcp 在哪一层？

```text
1、计算机网络分为：应用层、传输层、网络层、数据链路层、物理层
2、TCP 位于传输层
```

- 说说 ip 协议

```text
1、IP 协议位于 TCP/IP 协议的网络层，主要用于互联网通讯。IP 协议为上层协议提供无状态、无连接、不可靠的服务
2、IP 地址可分为 5 大类：
	(1) A 类地址：0-127，私有地址为：10.0.0.0-10.255.255.255
	(2) B 类地址：128-191，私有地址：172.16.0.0-172.31.255.255
	(3) C 类地址：192-223，私有地址：192.168.0.0-192.168.255.255
	(4) D 类地址：224-239
	(5) E 类地址：240-254
```

- http 和 https 的区别

```text
1、HTTP：
	(1) 是什么：
		① 超文本传输协议，是互联网上应用最为广泛的一种网络协议，设计 HTTP 协议的初衷是为了提供一种用于发布和接受 HTML 页面的方法，它使得浏览器更加高效
		② HTTP 协议以明文方式发送信息，通过抓包等方式可以轻松的截获 HTTP 请求，可以直接获取其中传送的信息，安全性不高
2、HTTPS：
	(1) 是什么：
		1) 以安全为目标的 HTTP 通道，是安全版的 HTTP 协议。
		2) HTTPS 协议以 SSL 为安全基础，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持
		3) SSL 协议可分为两层：
			① SSL 记录协议（SSL Record Protocol）：它建立可靠传输 TCP 协议之上，为高层协议提供数据疯转、压缩、加密等基本功能支持
			② SSL 握手协议（SSL HandShark Protocol）：它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份验证、协商加密算法、交换加密密钥等
	(2) 优点：
		① 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
		② HTTPS 协议是由 SLL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中被窃取、修改、确保数据完整性
		③ HTTPS 是如今框架中最安全的解决方案，虽然不是绝对安全，但是它大大加大了中间人的攻击成本
	(3) 缺点：
		① HTTPS 协议握手比较耗时，会使页面加载时间延长
		② HTTPS 协议连接不如 HTTP 协议连接高效，会增加数据开销，甚至已有的安全措施会因此收到影响
		③ SSL 证书通常需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPv4 资源支撑不起这个消耗
		④ HTTPS 协议的加密范围比较有限，SSL 证书的信用链体系不安全，某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行
3、区别：
	(1) HTTPS 协议需要到 CA 申请证书，一般免费的证书很少，因而需要一定的费用
	(2) HTTP 是超文本传输协议，信息的明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议
	(3) HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，HTTP 使用的是 80 端口，HTTPS 使用的是 443 端口
	(4) HTTP 的连接很简单，是无状态的。HTTPS 协议是由 HTTP + SSL 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 安全
```

- http 状态码

```text
1、1XX：提示信息，表示请求已接受，继续处理
2、2XX：成功，表示请求已经被成功接受、理解、接受
	(1) 200：OK，是最常见的成功状态码，表示一切正常，如果是 HEAD 请求，浏览器返回的响应头都会有 body 数据
	(2) 204：No Content，也是常见的成功状态码，与 200 基本相同，但是响应头中没有 body 数据
	(3) 206：Partical Content，应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是一种成功的状态码
3、3XX：表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取数据，也就是重定向 301 和 302 都会在响应头里使用 Location 字段，指明后续要跳转的 URL，浏览器会自动重定向到新的URL
	(1) 301：Moved Permanently，表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在获取新内容的同时，也将旧的网址替换为重定向之后的网址
	(2) 302：Moved Temporarily，表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 进行访问，搜索引擎会抓取新的内容而保留旧的网址
	(3) 304：Not Modified，表示资源未修改，不具备跳转的含义，重定向已存在的缓冲文件，也成为缓冲重定向，用于缓存控制
4、4XX：表示客户端发送报文有误，服务器无法处理
	(1) 400：Bad Request，表示客户端请求的报文有错误
	(2) 401：Unauthorized，缺失或错误的认证，这个状态码必须和 WWW-Authenticate 报头一起使用，
	(3) 403：Forbidden，表示服务器禁止访问，并不是客户端的请求出错
	(4) 404：Not Found，表示请求的资源在服务器上不存在或未找到
5、5XX：表示客户端请求报文正确，但是服务器处理时发生了内部错误，属于服务器的错误
	(1) 501：Implemented，表示客户端请求的功能还不支持
	(2) 502：Bad Gateway：通常书服务器作为网关或代理时返回的状态码，表示服务器滋生工作正常，访问后端服务器发生了错误
	(3) 503：Service Unavailable，表示服务器忙，暂时无法响应
	(4) 504：Gateway Timeout，网关超时，由作为网关或者代理的服务器使用，表示不同及时的从远程服务器获取应答
```

- https 如果没有证书会加密吗？怎么加密的？

```text
1、会，客户端和服务端会协商出一个加密方式进行加密
```

- 对称加密不发送密钥的话会不会更安全，比如自己开发个 app，两边都是自己的，服务端放一个客户端放一个，直接用密钥来对称加密，有啥问题

```text
1、不安全：
	① 如果内部员工跑路则会带走密钥，这样密钥就不安全了
	② 如果 APP 源文件被破解，那么会导致密钥泄漏
```

- TCP 三次握手，第三次握手发送方是否可以携带信息

```text
1、可以发送数据：
	(1) 第一次第二次握手时不能发送数据。如果可以携带数据，那么如果有人要恶意攻击服务器，攻击者每次都在第一次握手的 SYN 报文中放入大量数据，疯狂重复的发送 SYN 报文，这样服务器会花费大量的内存控件来缓存这些报文，促使了 SYN 攻击
	(2) 第三次握手时可以携带数据。经过前面的第一、二次握手，客户端已经处于连接状态，客户端已经知道服务端的收发功能是正常的，可以携带数据
```

- 多路复用 解决了什么问题

```text
1、引入二进制数据帧和流的概念，帧对数据进行顺序标识，浏览器对收到的数据进行顺序排序并合并，服务器就可以并行的传输数据，缓解了 HTTP1.1 中队头阻塞问题
2、由于同域名下的多个请求公用同一个 TCP 连接，减少了 TCP 连接的握手次数，提高了请求速度
```

- 服务器推送和 websocket 区别？

```text
1、服务器推送一般用于以服务器根据解析 index.html 同时推送 CSS/JS 等资源，从而避免多次向服务器发送多次请求
2、Websocket 用于服务器与客户端手动编写代码去推送数据
```

- WebSocket 如何建立连接，手写 WebSocket 建立过程

```text
1、客户端会发送一个握手包给服务端：
	(1) 方法必须是 GET
	(2) HTTP 版本不能低于 HTTP1.1
	(3) 必须包含 Upgrade 头部，值必须是 websocket
	(4) 必须包含 Sec-WebSocket-Key 头部，值是一个 Base64 编码的 16 字节随机字符串
	(5) 必须包含 Sec-WebSocket-Version 头部，值必须为 13
2、服务端验证客户端的握手包符合规范之后会发送一个握手包给客户端：
	(1) 必须包含 Connection 头部，值必须为 Upgrade
	(2) 必须包含一个 Upgrade 头部，值必须为 websocket
	(3) 必须包含一个 Sec-WebSOcket-Accept 头部，值按照一下规则生成：
		① 首先将一个固定的字符串 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接到 Sec-WebSocket-Key 对应值的后面
		② 对拼接后的字符串进行一次 SHA-1 计算
		③ 将计算结果进行 Base-64 编码
3、客户端收到服务端的握手包之后，验证报文格式符合规范后，以 2 中计算 Sec-WebSocket-Accept 的方式计算 Sec-WebSocket-Accept，并于服务端的进行比较，成功后进行后续的数据交互
```

- 代理和反向代理

```text
1、正向代理：正向代理是一个位于客户端和服务端之间的dialing服务器，为了从袁术服务器获取内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后黛米向目标服务器转交并且将获取的内容返回给客户端
2、反向代理：反向代理正好相反，反向代理就好像服务器，并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好像是自己的一样，因此而客户端不会感知到反向代理后面的服务，也因此不需要客户端进行任何设置，只需要把反向代理当成真正的服务器就好了
3、区别：
	(1) 正向代理是代理客户端，为客户端收发请求，是真实的客户端对服务器不可见，而反向代理是代理服务器端，为服务器收发请求，是真实服务器对客户端不可见
	(2) 是否指定目标服务器
	(3) 客户端是否需要做设置
```

- CDN

```text
1、CDN（Content Delivery Network）内容分发网络。CSN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速率和命中率
2、CDN 利用缓存技术，将数据缓存在里用户最近的地方，是用户以最快的速度获取，解决如何将数据快速可靠的从源站传递到用户的问题。用户获取数据时，不需要直接从原站获取，通过 CDN 分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少原站负载压力的目的
3、访问流程：
	(1) 用户浏览器输入目标域名，浏览器查找本地 DNS 缓存，没有则向网站的 DNS 服务器请求
	(2) 浏览器向 DNS 服务器请求对该域名的解析，由于 CDN 对域名进行了调整， DNS 服务器最终会将域名解析权交给CDN 专用的 DNS 服务器
	(3) CDN 的 DNS 负载均衡系统解析域名，把对用户响应最快的 IP 地址返回给用户
	(4) 用户使用该 IP 地址发送请求
	(5) CDN 负载均衡设备会为用户选择一个合适的缓存服务器提供服务
	(6) 用户向缓存服务器响应用户请求，将用户所需的内容返回给用户
```

- DOS、 DDOS 攻击原理和防范

```text
1、原理
	(1) DoS（Denial of Service）攻击，拒绝服务，一台或多台计算机对受攻击服务器的某一个端口发送大量无关的UDP报文，导致整个通道内的正常服务无法进行，常见的 DOS 攻击手段有：
		① TearDrop
		② Land
		③ Jolt
		④ IGMPNuker 等
	(2) DDoS（Distributed Denial of Service）攻击，分布式拒绝服务，属于 DoS 攻击的一种，DDoS 攻击主要将多个计算机联合起来，并对一个或多个计算机目标、服务器发动攻击，从而攻击的威力会成倍增加，这种攻击的特点就是利用了 TCP/IP 协议的漏洞。常见的 DDoS 攻击手段有：
		① SYNFlood
		② ACKFlood
		③ ICMPFlood
		④ ConnectionsFlood
		⑤ ScriptFlood
		⑥ ProcyFlood 等
2、区别：DDoS 相对于 DoS 来说数量大、攻击性强
	(1) DoS 侧重于通过对故武器特定的漏洞，利用 DoS 攻击导致网阔连接失败、系统崩溃、电脑死机等情况发生
	(2) DDoS 攻击通过很多“僵尸主机”向木匾主机发送大量看似合法的流量包，从而造成网络阻塞或服务器资源耗尽而导致拒绝服务，力图 TCP 收报丢弃方案，防护：
		① 限制请求
		② 炼制连接数量
		③ 增加内存
		④ 分布式集群防御
3、防御：
	(1) 增加宽带
	(2) CDN，各地部署子服务器，当子服务器收到攻击后，其他地区的服务器和主服务器不会收到影响
	(3) BGP 流量清洗，通过 BGP 将通道内的无用 UDP 报文清晰干净再转给服务器
```

- 301 和 302 的区别

```text
1、301：永久重定向，表示所请求的资源已经永久转移到新的位置，这包含域名的改变或者是资源路径的改变。浏览器会根据响应头中的相关字段自动进行转跳：
	(1) Location：表示重定向后的资源新位置
	(2) Request URL：表示请求的资源旧位置
2、302：临时重定向，表示所请求的资源临时转移到新的位置，一般是 24 至 48 小时之内的转移会用 302
3、区别：
	(1) 302 虽然是重定向，但是由于是临时的，所以浏览器对自己的 URL 缓存不会改变，依旧是原来路径
	(2) 301 是永久的，所以浏览器会改变自身的 URL 缓存，将旧的路径换位新的路径
	(3) 302 临时重定向不会将原搜索流量导入到新的地址，但是 301 会，对于搜索排名有很大作用
	(4) 302 URL 劫持，将他人的内容盗用给自己的网站
	(5) 302 网站降权，由于使用 302 跳转桃枝搜索引擎认为i是非法引用，来干扰搜索结果，所以会进行降权操作
```

- 为什么要重定向？

```text
1、网站会被大量用户收藏到自己的浏览器收藏夹中，收藏的就是 URL，如果网站资源路径发生变化，如果不进行重定向操作，那么当用户再次访问收藏资源时，由于原位置已经不存在，那么服务器只会给用户返回 404
2、因此出现了重定向的操作，即当用户访问位置改变了的资源时，通过服务器的返回的值资源位置已经改变，随机浏览器会访问改变后的资源位置，就不会发生 404
```

- cookie cookie 里面的 domin 和 path httpOnly

```text
1、domain、path：决定哪些 HTTP 请求会带上 Cookie，如 Domain 为 www.a.com，path 属性是 /，意味着 www.a.com 下的所有根路径和子路径都会带上 Cookie。如果 path 值为 /asd，那么只会在子路径 /asd 下的请求才会带上 Cookie
2、httpOnly：指定该 Cookie 无法通过 JS 拿到，防止 Cookie 被脚本读取，只有浏览器发出 HTTP 请求的才会带上该 Cookie
```

- cookie 的 sameSite
- 在 www.a.com 到 www.b.com 的时候会带上吗？怎么才能带上

```text
1、不会，由于同源策略的存在
2、将浏览器如 Chrome 的 samesite 关闭就行
```

- cookie 在 http to https 的时候会带上吗

```text
1、不会
2、配置服务器，设置 Cookie secure 属性
```

- KeepAlive 说一下

```text
1、TCP 的 KeepAliive：侧重在保持客户端和服务端的连接，乙方会不定时的发送心跳包给另一方，当一方断掉的时候，另一方定时发送几次心跳包，如果没有回应，说明对方已经关闭，就断开连接
2、HTTP1.1 中的 keep-alive：当客户端发送带有 Connection: keep-alive 头的 TCP 连接请求给服务端，这个连接就可以多次使用，多个请求都可以通过这个已经建立的连接进行数据交互，无需再次连接，减少握手次数，提高交互速度
```

- cors 原理

```text
1、CORS 是 W3C 标准，全称是"跨域资源共享"(Cross-origin resource sharing)。它允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制 cors 规范允许服务端向浏览器返回一些 HTTP Headers，浏览器可以通过这些 HTTP Headers 来决定是否突破同源策略的限制最主要的 HTTP Headers：
    (1) 目标服务器允许进行跨域访问的网站(* 表示允许所有网站，www.baidu.com 指定 这个网站可以进行跨域访问) Access-Control-Allow-Origin: *
	(2) cors 还有两种类型的请求：simple 简单请求和 preflight 预检请求，根据请求方式的不同由浏览器确定使用哪种方式
    	1) simple 简单请求：
			① API 方法是 GET、POST、HEAD，
			② Content-Type 请求头包含：application/x-www-form-urlencoded，multipart/form-data，text/plain
            如果请求包含以上所有的条件，将会发送简单请求，如果 api 被视为简单请求，那么这个请求将直接发送给服务端，服务器使用 HTTP Headers 进行响应，浏览器将通过判断 Access-Control-Allow-Origin 来决定是否可以通过同源策略的限制，进行下一步处理
		2) preflight 预检请求：
        	如果 api 请求不满足上述的简单请求的条件，那么都将发送预检请求，如一个 get 请求头中 Content-Type: application/json 他将会发送预检请求，预检请求头中包含几个关键的头：
            	① Access-Control-Request-Method：GET，用来告诉服务区浏览器将会使用哪种方法发送请求
            	② Access-Control-Request-Headers: X-Custom-Header，（非必要）字段以逗号分隔，指定请求会额外发送哪些头信息之后服务器收到预检请求后检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段后确定允许跨域请求，对此做出回应，如果预检失败，则不会发送后续真正的请求。
```

```text
https://www.nowcoder.com/discuss/827428
```

- 网络分层结构

```text
TCP/IP 五层模型：
1、应用层：为应用程序提供交互服务。在互联网中的应用层协议有很多，如：域名系统 DNS，HTTP 协议、STMP 协议等
2、传输层：负责向两台主机进程之间的通讯提供数据传输服务，把应用层的报文封装成 TCP 报文段或 UDP 的用户数据报进行传递。传输层协议主要有：传输控制协议 TCP、用户数据报协议 UDP
3、网络层：为两台主机提供通信服务，选择合适的路由交换结点，确保数据及时送达，并把运输层产生的报文段或用户数据报封装成 IP 数据报进行传递。网络层主要协议有：IP 协议
4、数据链路层：为两台主机提供通信服务，在两个相邻结点之间传输数据时，数据链路层将网络层交下来的 IP 数据包组装成帧，在两个相邻结点的链路上传递帧
5、物理层：实现相邻节点之间比特流的透明传输，尽可能减少传输介质和物理设备之间的差异
```

- 三次握手

```text
1、第一次握手：客户端向服务器发起建立连接的请求，客户端向服务端发送的字段中包含标志位 SYN=1，系列号 seq=x。第一次握手前客户端的状态为 CLOSE，第一次握手后客户端的状态变为 SYN-SENT，此时服务器的状态为 LISTEN
2、第二次握手：服务端在收到客户端发送过来的报文后，会随机生成一个服务端的起始序列号 y，然后给客户端回复一段报文，其中包括标志位 SYN=1，ACK=1，序列号 seq=y，确认号 ack=x+1。第二次握手前服务端的状态为 LISTEN，第二次握手后服务端的状态为 SYN-RECV，客户端的状态为 SYN-SENT
3、第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包括标志位 ACK=1，序列号 seq=x+1，确认号 ack=y+1。第三次握手前客户端的状态为 SYN-SENT，服务端的状态为 SYN-RECV，握手后客户端和服务端状态都为 ESTABLISHED。此时连接建立完毕
```

- 两次握手可以吗？

```text
不可以，因为第三次握手主要是为了防止已经失效的连接请求报文段突然又传到了服务端，导致问题产生，比如：
1、客户端 A 向 服务端 B 发送连接请求，可能由于网络阻塞，导致服务端 B 没有收到建立连接的请求，导致客户端 A 没有收到来自服务端的确认报文，于是客户端 A 又向服务端 B 发送了连接请求
2、第二次发送的连接请求 服务端 B 收到并返回了确认报文，连接创建成功，待数据传输完毕后释放了连接
3、客户端 A 第一次发送的连接请求等到连接释放后到达了服务端 B，此时服务端 B 误以为客户端 A 想建立连接，于是服务端 B 向客户端 A 发送了确认报文
4、如果不采用三次握手，只要服务端 B 发出确认报文，就建立了连接，此时客户端 A 既不会响应服务端 B 的确认，也不会发送数据，则服务端 B 将一直等待 A 发送数据，浪费资源
```

- 四次挥手

```text
1、A 的应用进程先向 B 发出连接释放报文段 FIN=1，seq=u，并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 B 确认
2、B 收到 A 的连接释放报文段后向 A 发出确认报文段（ACK=1，seq=v，ack=u+1），B 进入 CLOSE-WAIT（关闭等待）状态，此时 TCP 处于半关闭状态，A 到 B 的连接释放
3、A 收到 B 的确认报文段后，进入 FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接释放请求
4、B 发送完数据，就会向 A 发送连接释放报文段（FIN=1，ACK=1，seq=w，ack=u+1），B 进入 LAST-ACK（最后确认）状态，等待 A 的确认
5、A 收到 B 的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A 进入 TIME-WAIT（时间等待）状态。此时 TCP 连接未释放掉，需要经过时间等待计时器设置的时间 2MSL（最大报文段生成时间）后，A 才进入 CLOSED 状态，B 收到 A 发出的确认报文段后关闭连接，若没有收到 A 发出的报文段，B 就会重传连接释放报文段
```

- 第四次挥手为什么要等待 2MSL？

```text
1、保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段可能丢失，B 收不到这个确认报文，就会超时重传连接释放报文段，然后 A 可以再 2MSL 时间内接收到这个重传的连接释放报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，最后 A 和 B 都进入到了 CLOSED 状态，若 A 在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后直接释放连接，则无法收到 B 重传的连接释放报文段，所以不会再发一次确认报文段，B 就无法正常进入到 CLOSED 状态
2、防止已经失效的连接请求报文出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，是下一个新的连接中不会出现旧的请求连接报文段
```

- 为什么是四次挥手？

```text
因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。但是在关闭连接时，当服务端收到客户端发出的连接释放报文时，很可能并不会立即关闭 Socket，所以服务端先回复一个 ACK 报文，表示服务端收到了客户端发的连接释放报文。只有等到服务端所有的报文都发送完了，这时的服务端才能发送释放报文，之后两边才会真正的断开连接，所以需要四次握手
```

- TCP 有哪些特点？

```text
1、TCP 是面向连接的运输层协议
2、TCP 提供可靠交付的服务
3、TCP 提供全双工通讯
4、TCP 面向字节流，把数据看成一串无结构的字节流
```

- TCP 和 UDP 的区别？

```text
1、TCP 面向连接，UDP 面向无连接
2、TCP 提供可靠的服务，UDP 不保证可靠交付
3、TCP 面向字节流，把数据看成一串无结构的字节流，UDP 面向报文
4、TCP 具有拥塞控制，UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
5、TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一，多对多的通讯方式
6、TCP 首部开销 20 字节，开销大，UDP 首部开销 8 字节，开销小
```

- HTTP 协议的特点？

```text
1、HTTP 允许传输任意类型的数据。传输的类型由 Content-Type 加以标识
2、无状态。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话与下一次会话之间没有联系
3、支持客户端/服务器模式
```

- HTTP 报文格式

```text
1、HTTP 请求由请求行、请求头部、空行、请求体四个部分组成
	(1) 请求行：包括请求方法、访问资源的 URL、使用的 HTTP 协议版本。GET 和 POST 是最常见的 HTTP 请求方法，其他还有：DELETE、HEAD、OPTIONS、PUT、YRACE
	(2) 请求头：格式为属性名: 属性值，服务端根据请求头来获取客户端信息，主要有 Cookie、Host、Connection、Content-Type、Accept-Encoding、User-Agent
	(3) 请求体：用户的请求数据，如用户名、密码等
2、HTTP 响应也由四个部分组成：状态行、响应头、空行、响应体
	(1) 状态行：协议版本、状态码、状态描述
	(2) 响应头：主要有：Connection、Content-Type、Content-Encoding、Content-Length、Set-Cookie、Last-Modified、Cache-Control、Expires
	(3) 响应体：服务器返回给客户端的内容
```

- POST 和 GET 的区别？

```text
1、GET 请求参数通过 URL 传递，POST 请求的参数放在请求体中
2、GET 请求会被浏览器主动缓存，POST 不会
3、GET 请求只能进行 URL 编码，POST 支持多种编码方式
4、GET 请求会被保存在浏览器的历史记录中，POST 不会
5、GET 请求安全性低，会将参数拼接在 URL 上，POST 则存放在 body 中，安全性高
6、GET 请求参数的多少局限于浏览器的限制，一般为 1024kb，POST 则没有限制
```

- HTTP 长连接和短连接？

```text
1、HTTP1.0 默认使用短链接。浏览器和服务器每进行一次 HTTP 请求就要建立一次连接，任务结束就中断连接
2、HTTP1.1 起默认使用长连接。要使用长连接，客户端和服务器的 HTTP 首部的 Connection 都要设置成 keep-alive
3、长连接是指复用 TCP 连接。多个 HTTP 请求可以复用同一个 TCP 连接，大大节省了 TCP 连接与断开的的消耗
```

- HTTP0.9、HTTP1.0、HTTP1.1、HTTP2.0 和 HTTP3.0 的区别？

```text
1、HTTP0.9：
	(1) 需求简单，用来在网络间传递 HTML 超文本内容，所以被称为超文本传输协议
	(2) 只有一个 GET 请求，并且只支持 HTML 格式的字符串，不能返回其他格式。服务器接收到请求信息后，读取对应的 HTML 文件，并将数据以 ASCII 字符格式返回给客户端，不返回头信息
	(3) 基于 TCP 协议，建立好连接后只发送一个 GET 行请求，如 GET /index.html，不支持长连接
2、HTTP1.0：
	(1) 可以发送任意格式的数据
	(2) 引入请求头、响应头、状态码等基本信息。每次通讯都必须包括头信息（HTTP Header）
	(3) 新增了缓存机制，用来缓存已经下载过的数据
	(4) 不支持长连接，握手挥手频繁，使得连接传输效率低
	(5) 新增请求方法，如：HEAD、POST
3、HTTP1.1
	(1) 新增默认支持长连接，使得一个 TCP 连接上可以传输多个 HTTP 请求，减少了握手与挥手的次数，大大提高了传输效率。目前浏览器支持同时建立 6 个持久连接
	(2) 引入 Cookie、身份认证、状态管理等相关请求头和响应头
	(3) 新增了请求方法，如：PUT、DELETE、PATCH、OPTIONS、TRACE
	(4) 支持断点续传
	(5) 加入管道机制（pipeline）。浏览器可以同时发送多个请求，减少浏览器请求资源时间
4、HTTP2.0
	(1) 废弃管道机制（pipline），使用多路复用机制。允许单一的HTTP/2连接发起多重请求-响应信息，不用按顺序一一对应，减缓了队头阻塞问题
	(2) 采用二进制分帧的形式传递数据，解析更高效
	(3) 头部压缩：将 Header 从数据中分离，并封装成头帧和数据帧。使用特定算法压缩头帧，有效减小头信息大小，并且在客户端和服务端之间记录了之前发过的键值对，对于相同的数据，不会重复发送
	(4) 服务端推送：允许服务端向客户端推送资源，无需客户端发送请求向服务端获取
5、HTTP3.0
	(1) 废弃 TCP 协议，使用基于 UDP 协议开发的新的 QUIC 协议，解决了 HTTP3.0 之前版本基于 TCP 协议所带来的队头阻塞问题
	(2) 默认加密
	(3) 握手延迟低
```

- HTTPS 与 HTTP 的区别？

```text
1、HTTP 时超文本传输协议，信息是明文传输；HTTPS 则是具有安全性的 SSL 加密传输协议
2、HTTP 和 HTTPS 用的端口不同，HTTP 是 80 端口，HTTPS 是 443 端口
3、HTTPS 需要到 CA 申请证书，需要一定的费用
4、HTTP 运行在 TCP 上，HTTPS 运行在 SSL 协议上，SSL 协议运行在 TCP 上
```

- 什么是数字证书？

```text
1、服务端可以向证书颁发机构 CA 申请证书，以避免中间人攻击（防止证书被篡改）。证书包括三部分内容：证书内容、摘要算法和数字签名，签名是为了验证身份。服务器把证书传输给浏览器，浏览器从证书里获取公钥，证书可以证明该公钥对应本网站
2、数字签名过程：
	(1) CA 使用证书签名算法对证书内容进行 hash 运算
	(2) 对 hash 后的值用 CA 的私钥进行加密，得到数字签名
3、浏览器验证过程
	(1) 获取证书，得到证书内容、证书签名算法、数字签名
	(2) 用 CA 机构的公钥对数字签名进行解密（由于是浏览器信任的机构，所以浏览器会保存它的公钥）
	(3) 用证书里的签名算法对证书内容进行 hash 运算
	(4) 比较解密后的数字签名和证书内容做 hash 运算后得到的哈希值，相等则表明证书可信
```

- HTTPS 原理

```text
1、首先进行 TCP 三次握手
2、然后客户端发起一个 HTTPS 连接建立请求，客户端先发送一个 Client Hello 的包，包含：
	(1) 客户端支持的 TLS 版本
	(2) 密码套件
	(3 )一个客户端生成的随机数（用于后续创建密钥）
3、服务端接收到客户端发来的请求，服务端确认 TLS 版本，如果浏览器不支持，则关闭加密通讯，然后发送一个 Server Hello 的包，包含：
	(1) 密码套件
	(2) 一个服务端生成的随机数（用于后续创建密钥）
	(3) CA 证书
4、客户端收到服务端的响应，从证书中获取到证书内容、数字签名、摘要算法，浏览器使用浏览器或系统中的 CA 公钥对 CA 证书中的数字签名进行解密，获取到摘要，浏览器首先使用摘要算法对证书内容进行 hash 运算生成摘要，对比两个摘要是否一致，若一致则证明证书可信。之后客户端从证书中获取到服务端的公钥。客户端回应服务端一个使用证书中服务端公钥加密后的 Client key Exchange 包，包含：
	(1) 一个随机数（客户端和服务端会根据这个随机数加上之前的两个随机数生成对称加密密钥，所以每次链接的密钥都不相同）
	(2) 加密通信算法改变通知（后续客户端和服务端对通过上面三个随机数所生成的对称加密密钥进行加密通讯）
	(3) Finished 消息，结束通知，把之前所有发送的数据生成一个摘要，再用这个生成的密钥进行加密，用来验证加密通讯是否可用以及之前的握手信息是否被篡改，让服务端做验证
5、服务端响应客户端：
	(1) 加密通信算法改变通知
	(2) Finished 消息，结束通知，把之前所有发送的数据生成一个摘要，再用这个生成的密钥进行加密，用来验证加密通讯是否可用以及之前的握手信息是否被篡改，让客户端做验证，如果双方验证加密解密都没有问题，则握手完成。最后就用会话密钥加解密 HTTPS 请求和响应
```

- DNS 的解析过程？

```text
1、浏览器搜索自己的 DNS 缓存
2、若没有，则搜索操作系统中的 DNS 缓存和 hosts 文件
3、若没有，则操作系统将域名发送给本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查询成功则返回，否则就向域名服务器发起查询请求，有两种查询方式：
	(1) 迭代查询：（一般在域名服务器中使用，以避免服务器压力过大）
		① 本地域名服务器先向根域名服务器查询，将查询到的顶级域名服务器地址返回
		② 再向查询出来的顶级域名服务器查询，将查询到的权威域名服务器地址返回
		③ 最后向权威域名服务器请求域名，返回域名对应 IP 地址
	(2) 递归查询：（一般在客户端的 DNS 服务器使用）
		① 本地域名服务器向根域名服务器查询
		② 然后通过查询到的顶级域名服务器地址继续向权威域名服务器查询
		③ 再通过查询到的权威域名服务器地址查询域名地址
		④ 返回查询到的域名地址返回给本地域名服务器
4、本地域名服务器将得到的 IP 地址返回给操作系统，并将 IP 地址缓存起来
5、操作系统将 IP 地址返回给浏览器，并将 IP 地址缓存起来
6、浏览器获取到目标域名 IP ，并将 IP 缓存起来
```

- 浏览器中输入 URL 返回页面过程？

```text
1、域名解析，找到域名 IP
2、利用域名解析出来的 IP 地址进行 TCP 三次握手
3、建立 TCP 请求后，浏览器向服务端发送一个 GET 请求
4、服务器响应请求，返回响应数据
5、浏览器解析响应内容，进行渲染：
	(0) 从上到下依次解析，遇到 CSS 会阻塞 DOM 的渲染，不会阻塞 DOM 的解析，遇到 JS 会阻塞 JS 的执行；遇到 JS 会阻塞 DOM、CSS 的解析和渲染
	(1) 解析 HTML 生成 DOM 树
	(2) 解析 CSS 生成 CSSOM 树
	(3) 结合 DOM 树和 CSSOM 树，生成 Render（渲染）树（只包含可见结点）
	(4) 布局 Render 树：浏览器弄清楚各个节点在页面中的确切位置
	(5) 绘制 Render 树：遍历渲染树将每个节点绘制出来
```

- 什么是 cookie 和 session？

```text
1、由于 HTTP 协议是无状态的，需要用某种机制来标识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术就是 Cookie、Session
2、Cookie：是由服务器发送给客户端的特殊信息，这些信息以文本文件的形式存放在客户端，然后客户端每次向服务器发送请求的时候就会携带上这些特殊的信息。服务端在接收到这些带有 Cookie 的请求后，就会通过分析存放于 HTTP 请求头的 Cookie 得到客户端持有的信息，从而动态生成于客户端相应的内容。网页中的记住密码就是通过 Cookie 实现的。工作流程：
	(1) servlet 创建 Cookie，保存少量信息，发送给客户端
	(2) 浏览器获得服务器发送的 Cookie 数据，将自动保存在浏览器端
	(3) 下次访问服务端的时候浏览器会自动带上 Cookie 数据发送给服务端
3、Session：首先浏览器访问服务端的时候，服务端会首先检查这个客户端是否包含了 Session 标识，称为 sessionid，如果已经包含一个 sessionid，就说明以前已经为客户端创建过 Session，服务端就按照这个 sessionid 来把 Session 检索出来使用；如果客户端不包含 sessionid，则服务端就会创建一个 Session，并且生成一个与之关联的独一无二的 sessionid 存放到 Cookie 中，这个 sessionid 会随着本次请求的响应返回给客户端，这样在交互过程中，浏览器每次请求都会携带上 sessionid，服务端根据这个 sessionid 来找到对应的 Session，以此来达到共享数据的目的。Session 不会随着浏览器的关闭而死亡，而是等待超时时间
```

- Cookie 和 Session 的区别？

```text
1、存储位置不同：Cookie 存储在客户端，Session 存储在服务端
2、有效期不同：Cookie 可设置为长时间保存，Session 一般失效时间短，客户端关闭或者超时时失效
3、安全性不同：Cookie 存储在客户端，容易被窃取，Session 存储在服务端，安全性较好
4、存储大小不同：单个 Cookie 保存的数据不能超过 4kb，Session 没有存储上限，但是由于每个会话服务端都会创建一个 Session 存储在服务端中，会影响服务端的性能
```

- 什么是对称加密和非对称加密？

```text
1、对称加密：通讯双方使用相同的密钥进行加密
	(1) 优点：速度快
	(2) 缺点：安全性低，只要密钥泄漏，会导致密文被破解
	(3) 常见的对称加密算法：AES、DES
2、非堆成加密：需要生成两个密钥，公钥和私钥，公钥的公开的，任何人都可以拿到，私钥是私人保管的。公钥加密，私钥解密或者私钥加密，公钥解密
	(1) 优点：安全性高，由于私钥由自己保管，一般不会被泄漏
	(2) 缺点：速度慢，计算量大，加解密速度慢
	(3) 常见的非对称加密算法：RSA、DSA
```

- 滑动窗口机制

```text
1、TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方的发送速率，保证接收方来得及接收。
2、TCP 会话的双方都各自维护一个发送窗口和接收窗口，接收窗口大小取决于应用、系统、硬件的限制，发送窗口取决于对方通告的接收窗口。接收方发送的确认报文中的 window 字段可以用来控制发送方发送窗口的大小，从而影响发送放的速率，将接收方的确认报文的 window 字段设置为 0，则发送端不再发送数据
3、TCP 头包含 window 字段，16比特，代表窗口的字节数量，最大为 65535，这个字段接收端用来告诉发送端自己还有多少缓冲区可以接收数据，于是发送端可以根据接收端的处理能力来发送数据，而不会导致接收方处理不过来。接收的窗口大小约等于发送的窗口大小
```

- 详细讲一下拥塞控制？

```text
1、只要为了防止过多的数据注入到网络中。几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复
	(1) 慢开始：把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值，在每接收一个报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值，每经过一个传输伦茨，拥塞窗口 cwnd 就加倍，为了防止拥塞窗口 cwnd 增长过快引起网络拥塞，需要设置一个慢开始 ssthresh（slow start threshold 慢启动阀，一般为 16 比特） 状态变量：
		① 当 cwnd < ssthresh 时，使用慢开始算法
		② 当 cwnd > ssthresh 时，停止使用慢开始算法，改用拥塞避免算法
		③ 当 cwnd = ssthresh 时，可使用慢开始算法，也可以使用拥塞避免算法
	(2) 拥塞避免：让拥塞窗口 cwnd 缓慢增大，没经过一个往返时间 RTT 就把发送方的 拥塞窗口 +1，而不是加倍，这样拥塞窗口 cwnd 会按照线性规律缓慢增长
	(3) 快重传：有时个别报文段会在网络中丢失，但实际上网络未发生拥塞，如果发送方迟迟收不到确认，就会产生超时，就会被误认为网络发生了拥塞，这就导致发送方错误的启动了慢启动，把拥塞窗口设置为 1，大大降低了传输速率。快重传算法避免了这个问题，快重传算法要求接收方每接收一个失序的报文段后就立即发送重复确认，使发送方尽早的知道有报文段没有到达对方。发送方只要一连收到 3 个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等到重传计时器到期。
	(4) 快恢复：当发送方连续接收到三个重复确认，就会把慢开始门和 ssthresh 减半，接着把 cwnd 值设置为慢开始门跟 ssthresh 减半后的数值，然后开始执行拥塞避免短发，使拥塞窗口缓慢线性增大

```

- ARP 协议

```text
1、ARP 协议：地址解析协议，解决了同一个局域网上的主机和路由器 IP、MAX 地址的解析：
	(1) 每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系
	(2) 当源主机需要将一个数据包发送到目的主机时，会首先检查自己的 ARP 列表中是否存在该 IP 地址对应的 MAC 地址，如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括原书记的 IP 地址、MAC 地址以及目的主机的 IP 地址
	(3) 网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一样，如果不相同，就忽略这个数据包，如果相同，该主机首先会将发送端的 MAC 四肢和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址
	(4) 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据传输
	(5) 如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败
```

```text
https://www.nowcoder.com/discuss/826919
```

- 讲讲 OSI 协议

```text
1、应用层：
	(1) 为应用程序提供通讯和交互的协议
	(2) DNS、HTTP、SMTP、POP3
2、传输层：
	(1) 为两个主机中的进程间提供通用的数据传输服务
	(2) 把应用层的报文封装成 TCP 的报文段或 UDP 用户数据报进行传送
	(3) TCP、UDP
3、网络层：
	(1) 为两台主机之间提供通讯服务
	(2) 把运输层产生的报文段或用户数据报封装成 IP 数据包进行传送
	(3) ARP、ICMP
4、数据链路层：
	(1) 为两台主机之间的数据传输提供服务，两台主机之间的传输，总是在一段一段的链路上传送的，就需要链路层的协议
	(2) CSMA/CD、PPP
5、物理层：
	(1) 在传输媒体上进行传输比特流
	(2) 尽可能额为数据链路层屏蔽媒体和通讯手段的差异，把帧差拆分为比特流在传输没接上进行传输
	(3) 时分复用、频分复用等
```

### 应用层

- DNS 协议

```text
1、域名解析协议，提供了域名和 IP 地址之间相互转换的服务
2、可使用 TCP 或 UDP，但是一般用 UDP，因为速度快。只要一个请求，一个应答就完成了。但是 UDP 协议传输的内容不能超过 512 字节，一般客户端上的 DNS 服务器查域名，返回的内容都不超过 512 字节，使用 UDP足矣
```

- 为什么区域传送用 TCP

```text
1、区域传送：主 DNS 服务器上的数据有变化，需要向下传输变化的那部分数据，因为数据必然很大，并且要保证可靠传输，所以不能使用 UDP
```

- DHCP 协议

```text
1、动态主机配置协议
2、作用：
	(1) 给用户提供了即插即用的联网方式，用户不需要再手动的配置 IP 地址等信息
	(2) 其自动为用户配置 IP 地址、子网掩码、网关等
```

- 应用层还有没有别的协议？

```text
FTP、HDCP、SMTP
```

- URL 和 URI 的区别

```text
1、URI：统一资源标识符，可以唯一标识一个资源
2、URL：统一资源定位符，提供可以找到目标资源的路径
3、URL 是特殊的 URI
```

- HTTP 和 HTTPS 的区别

```text
1、端口：
	(1) http 默认端口 80，https 默认端口 443
2、安全性：
	(1) HTTP：
		① 运行在 TCP 协议之上，所有传输都是明文传输，客户端和服务端无法验证对方的身份
	(2) HTTPS：
		② HTTPS 同样运行在 TCP 协议之上，是安全版的 HTTP 协议。HTTPS 再中间加了一层 SSL/TLS 层，用来对传输的数据进行加密，所以 HTTPS 所有传输的内容都是经过加密的，加密使用组合加密：对称加密 + 非对称加密
```

### 传输层

- TCP 如何实现可靠传输？

```text
1、三次握手、四次挥手，保证连接可靠
2、超时重传：
	(1) TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就会重传这个报文段
3、ARQ 协议（自动重传请求）：
	(1) 停止等待 ARQ 协议：
		① 没发送完一个分组后就停止发送，等待对方确认（回复 ACK）。如果超过时间后还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发送下一个分组
		② 如果接收方接收到多个重复的分组，就丢弃该分组，同时发送确认
	(2) 连续 ARQ 协议：
		① 为提高信道利用率，发送方和接收方维持一个发送接收窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方对顺序到达的最后一个分组发送确认，表明到这个分组为止的所有扽组都已经确认收到
4、滑动窗口和流量控制：
	(1) TCP 利用滑动窗口实现流量控制，流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的 window 字段可以用来控制发送方的窗口大小，从而影响发送方的发送速率。将字段设置为 0，则发送方不能发送数据
5、拥塞控制：为了防止过多的数据注入到网络中，防止网络链路过载，TCP 双方维持两个个拥塞窗口（cwnd）的状态变量，其大小取决于网络拥塞程度，并且动态变化。TCP 拥塞控制采用了四种算法：慢开始、拥塞控制、快重传和快恢复
	(1) 慢开始：
		① 从最开始把 cwnd 这个状态设置为 1，发送方一次只能发送一个报文，收到确认后，cwnd 加倍。
		② 当遇到 ACK 确认超时后，直接慢开始，此时慢启动阈值（ssthresh）设置为超时时 cwnd 的一半，cwnd 设置为1，重新慢开始
	(2) 拥塞避免：
		① 达到阈值时进入拥塞避免模式，线性上升，每次 +1
	(3) 快重传：
		① 不使用快重传时，要求每次接收到的报文段都应该对最后一已经收到的有序报文段进行确认。例如已经收到 M1、M2，此时再收到 M4、M5、M6，没有收到 M3，还是应该发送 M2 的确认，M2 之后的数据包被丢弃，造成资源浪费。为解决这个问题，使用快重传。如果收到三个重复的 ACK 那么可以直到下一个报文段丢失，进行快重传，立即重发 M3.
	(4) 快恢复：
		① 在快重传的情况下，只是丢失了个别的报文段，而不是拥塞造成的超时，所以没必要重新进行慢开始，直接进行快恢复
		② 快恢复操作就是零阈值设置为 cwnd 的一般，并且把 cwnd 也直接变成原来的一半，直接进入拥塞避免阶段
6、校验和：保证首部数据的校验和。如果校验和有误，就丢弃该数据包，且不发送确认信息
7、重复丢弃：如果发送端重复发送相同数据包，接收端丢弃这些相同的数据包
```

- UDP 协议讲讲

```text
1、UDP 协议是面向无连接的：
	(1) 不进行三次握手、四次挥手
2、尽最大可能交付，没有拥塞控制：
	(1) 不进行丢包重传、拥塞控制，传输速度快
3、面向报文：
	(1) 报文头只有 8 字节，16 位的源端口，16 位的目的端口、16 位的 UDP 长度、16 位的 UDP 检验和
	(2) 直接把应用层的报文拿下来，然后加个 UDP 首部就向下进行传输
4、支持一对一、一对多、多对一、多对多的交互通讯
```

### 网络层

- 讲讲 ARP 协议

```text
1、地址解析协议，主要提供了由目的 IP 地址得到目的 MAC 地址的功能
2、工作流程：
	(1) 在同一个局域网中，主机 A 想往主机 B 发消息时，会先在自己的 ARP 缓存表中查找是否由对应主机 B 的 IP 所对应的 MAC 地址，如果没有，则发送一次广播 ARP 请求分组，主机 B 和主机 A 在同一个局域网，则主机 B 收到 ARP 请求分组时，会回发一个 ARP 响应分组，里面带有自己的 MAC 地址
	(2) 不在同一个局域网中，主机 A 会先把子网掩码和目的 IP 进行相与操作，发现不是一个网段，那么其下一跳就直接找路由器的默认网关。如果 ARP 缓存里没有默认网关的 MAC 地址，也需要先发一个 ARP 请求分组，等默认网关返回一个 ARP 响应分组后，就拿到了路由器默认网关的 MAC 地址，路由器进行广播，找到主机 B 的MAC 地址，然后主机 B 会回达一个 ARP 响应分组给主机 A
```

- 讲讲 ICMP 协议

```text
1、因特网控制报文协议，它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用
```

### 其他

- ack 什么时候发送，如果丢失了会怎么样
- 链路层、物理层都有什么作用？其他三层有什么作用？
- sack 是什么
- 重传 ack 的时机只有 ack 超时吗？
- 重复的报文被接收会怎么样？
- 拥塞窗口要不要把自己的大小发给接收方？为什么，有什么意义？
- 延迟 ACK 的意义是什么？
- 为什么不能每次直接发大的窗口？
- TCP / IP 五层架构对应什么协议
- 如果已经建立了连接，但是客户端突然出现故障了怎么办？
- 为什么有一个半关闭状态，明明客户端已经要求断开连接了，你还向客户端发送报文？这个数据没传完知道是什么，谁的数据没有传输完？
- TCP 连接池有一个四元组，讲讲。
- ICMP 协议位于哪一层
- url 访问的原理，包括 dns 原理，路由器上找的时候，有哪几种情况。
- http 和 tcp 是什么关系
- http 请求头有哪些？
- Http 断点续传问题
- 什么时候会向对端传窗口大小？
- 如果滑动窗口为 0 的时候，会怎么办？
- 如果视频聊天出现卡顿，如何在应用层面缓解？
- 视频面试用的是 TCP 还是 UDP，为什么？
- 加载 url 到界面显示出来的过程中发生了什么？并且这中间有哪些过程是可以优化的？
- Http 请求头都有什么内容？报文格式是什么，响应报文格式是什么
- Https 为什么要用对称加密 + 非对称加密 + CA 证书
- 讲讲 ping 命令，用了哪些协议？
- 讲讲 http 协议？
- Http 缓存机制讲讲
- http 的长连接讲一下
- 如何实现长连接
- 讲讲网络通信的多路复用
- 对称密钥为什么速度快？
- 多个服务器如何保存 session 一致性？
- TCP 连接的本质是什么
- 禁用了 cookie 以后，还能用 session 吗？如何？
- 计算机在设置 ip 的时候会设置哪些参数？（ip、子网掩码、网关）
- 子网掩码和网关的作用
- DNS 协议
- time_wait 状态有什么用？
- 如果用 udp 发送一个比较大的文件应该如何操作，如何确定文件是否发送完成，是否有丢失，如何对接收到的数据包进行组装，编号如何存放，用什么数据结构。
