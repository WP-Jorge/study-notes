<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<script>
			/**
			 * @param {number[]} nums
			 * @return {number}
			 */
			var maxSubArray = function (nums) {
				// 1.动态规划（空间未优化，时间复杂度O(n)，空间复杂度O(n)）
				// 教程: https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/
				// ① 初始化起始状态
				// ② 初始状态dp[0] = nums[0]
				// let dp = [];
				// dp[0] = nums[0];
				// // ③ max 用来记录最大值
				// let max = dp[0];
				// // ④ 一层循环
				// for (let i = 1; i < nums.length; i++) {
				//     // ⑤ 如果前面的数dp[i - 1] > 0，那么前面的加上后面的必定比之前的数大
				//     if (dp[i - 1] > 0) {
				//         dp[i] = dp[i - 1] + nums[i];
				//     } else {
				//         // ⑥ 如果前面的数 < 0，那么后面的数加上这个dp[i - 1]必定比之前的小，那么直接将dp[i] 赋值以nums[i]，使dp[i]从头开始计算
				//         dp[i] = nums[i];
				//     }
				//     // ⑦ 取dp[i]的最大值
				//     max = Math.max(max, dp[i]);
				// }
				// return max;

				// 2.贪心（时间复杂度O(n), 空间复杂度O(1)）
				let res = -Infinity;
				let sum = 0;
				for (let i = 0; i < nums.length; i++) {
					sum += nums[i];
					if (sum > res) {
						res = sum;
					}
					if (sum < 0) {
						sum = 0;
					}
				}
				return res;
			};
		</script>
	</body>
</html>
